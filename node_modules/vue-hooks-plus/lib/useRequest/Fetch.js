"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const utils = require("./utils");
class Fetch {
  constructor(serviceRef, options, setUpdateData, initState = {}) {
    __publicField(this, "pluginImpls");
    __publicField(this, "count", 0);
    __publicField(this, "state", {
      loading: false,
      params: void 0,
      data: void 0,
      error: void 0
    });
    __publicField(this, "previousValidData");
    this.serviceRef = serviceRef;
    this.options = options;
    this.setUpdateData = setUpdateData;
    this.initState = initState;
    this.state = {
      ...this.state,
      loading: !options.manual,
      ...initState
    };
  }
  setState(currentState = {}) {
    this.state = {
      ...this.state,
      ...currentState
    };
    this.setUpdateData(this.state);
  }
  setData(data, key) {
    console.warn("Please use 'setFetchState' instead of 'setData'");
    if (key instanceof Array) {
      key.forEach((k) => {
        this.state[k] = data;
        this.setUpdateData(data, k);
      });
    } else {
      this.state[key] = data;
      this.setUpdateData(data, key);
    }
  }
  setFetchState(data, key) {
    if (key instanceof Array) {
      key.forEach((k) => {
        this.state[k] = data;
        this.setUpdateData(data, k);
      });
    } else {
      this.state[key] = data;
      this.setUpdateData(data, key);
    }
  }
  runPluginHandler(event, ...rest) {
    var _a, _b, _c;
    const r = (_c = (_b = (_a = this.pluginImpls) == null ? void 0 : _a.map((i) => {
      var _a2;
      return (_a2 = i[event]) == null ? void 0 : _a2.call(i, ...rest);
    })) != null ? _b : []) == null ? void 0 : _c.filter(Boolean);
    return Object.assign({}, ...r);
  }
  async runAsync(...params) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
    this.count += 1;
    const currentCount = this.count;
    const { stopNow = false, returnNow = false, ...state } = this.runPluginHandler(
      "onBefore",
      params
    );
    if (stopNow) {
      return new Promise(() => {
      });
    }
    this.setState({
      loading: true,
      params,
      ...state
    });
    if (returnNow) {
      return Promise.resolve(state.data);
    }
    try {
      (_b = (_a = this.options).onBefore) == null ? void 0 : _b.call(_a, params);
    } catch (error) {
      this.setState({
        error,
        loading: false
      });
      (_d = (_c = this.options).onError) == null ? void 0 : _d.call(_c, error, params);
      this.runPluginHandler("onError", error, params);
      return new Promise(() => {
      });
    }
    try {
      let { servicePromise } = this.runPluginHandler("onRequest", this.serviceRef.value, params);
      const requestReturnResponse = (res) => {
        var _a2, _b2, _c2, _d2;
        if (currentCount !== this.count) {
          return new Promise(() => {
          });
        }
        const formattedResult = this.options.formatResult ? this.options.formatResult(res) : res;
        const origin = {
          data: res
        };
        this.setState({
          data: formattedResult,
          error: void 0,
          loading: false
        });
        (_b2 = (_a2 = this.options).onSuccess) == null ? void 0 : _b2.call(_a2, formattedResult, params);
        this.runPluginHandler("onSuccess", formattedResult, params, origin);
        this.previousValidData = formattedResult;
        (_d2 = (_c2 = this.options).onFinally) == null ? void 0 : _d2.call(_c2, params, formattedResult, void 0);
        if (currentCount === this.count) {
          this.runPluginHandler("onFinally", params, formattedResult, void 0);
        }
        return formattedResult;
      };
      if (!servicePromise) {
        servicePromise = this.serviceRef.value(...params);
      }
      const servicePromiseResult = await servicePromise;
      return requestReturnResponse(servicePromiseResult);
    } catch (error) {
      if (currentCount !== this.count) {
        return new Promise(() => {
        });
      }
      this.setState({
        error,
        loading: false
      });
      (_f = (_e = this.options).onError) == null ? void 0 : _f.call(_e, error, params);
      this.runPluginHandler("onError", error, params);
      if (utils.isFunction((_g = this.options) == null ? void 0 : _g.rollbackOnError) && ((_h = this.options) == null ? void 0 : _h.rollbackOnError(params)) || utils.isBoolean((_i = this.options) == null ? void 0 : _i.rollbackOnError) && this.options.rollbackOnError) {
        this.setState({
          data: this.previousValidData
        });
      }
      (_k = (_j = this.options).onFinally) == null ? void 0 : _k.call(_j, params, void 0, error);
      if (currentCount === this.count) {
        this.runPluginHandler("onFinally", params, void 0, error);
      }
      throw error;
    }
  }
  run(...params) {
    this.runAsync(...params).catch((error) => {
      if (!this.options.onError) {
        console.error(error);
      }
    });
  }
  cancel() {
    this.count += 1;
    this.setState({
      loading: false
    });
    this.runPluginHandler("onCancel");
  }
  refresh() {
    this.run(...this.state.params || []);
  }
  refreshAsync() {
    return this.runAsync(...this.state.params || []);
  }
  mutate(data) {
    const targetData = utils.isFunction(data) ? data(this.state.data) : data;
    this.runPluginHandler("onMutate", targetData);
    this.setState({
      data: targetData
    });
  }
}
module.exports = Fetch;
