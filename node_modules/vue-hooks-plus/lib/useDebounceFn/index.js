"use strict";
const debounce = require("lodash-es/debounce");
const vue = require("vue");
const _interopDefaultLegacy = (e) => e && typeof e === "object" && "default" in e ? e : { default: e };
const debounce__default = /* @__PURE__ */ _interopDefaultLegacy(debounce);
function useDebounceFn(fn, options) {
  const optionsRef = vue.ref(options || { wait: 1e3 });
  const debouncedRef = vue.ref();
  const createDebounced = () => {
    const { wait = 1e3, ...rest } = optionsRef.value;
    return debounce__default.default(fn, wait, rest);
  };
  debouncedRef.value = createDebounced();
  vue.watch(
    () => ({ ...optionsRef.value }),
    (newVal, oldVal) => {
      var _a;
      if (newVal.wait !== (oldVal == null ? void 0 : oldVal.wait) || newVal.maxWait !== (oldVal == null ? void 0 : oldVal.maxWait)) {
        (_a = debouncedRef.value) == null ? void 0 : _a.cancel();
        debouncedRef.value = createDebounced();
      }
    },
    { deep: true }
  );
  vue.onUnmounted(() => {
    var _a;
    (_a = debouncedRef.value) == null ? void 0 : _a.cancel();
  });
  return {
    run: (...args) => {
      var _a;
      return (_a = debouncedRef.value) == null ? void 0 : _a.call(debouncedRef, ...args);
    },
    cancel: () => {
      var _a;
      (_a = debouncedRef.value) == null ? void 0 : _a.cancel();
    },
    flush: () => {
      var _a;
      (_a = debouncedRef.value) == null ? void 0 : _a.flush();
    },
    updateOptions: (newOptions) => {
      optionsRef.value = newOptions;
    }
  };
}
module.exports = useDebounceFn;
