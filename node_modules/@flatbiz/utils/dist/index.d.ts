import { PriceOption } from '@dimjs/utils';

export interface IErrorInfo {
	code?: string;
	message?: string;
}
export type RquestResponse<T> = {
	code: string;
	message: string;
	data: T;
};
export interface UserInfo {
	accessToken: string;
}
export type LabelValueItem<T extends string | number | boolean = string | number> = {
	value: T;
	label: string;
};
export type TAny = any;
export type TPlainObject<T = TAny> = Record<string, T>;
export type TNoopDefine = () => void;
export type TNoopHasParamsDefine<T = TAny> = (x: T) => void;
/**
 * 设置默认值
 */
export type TSetDefaultDefined<T, D> = T extends undefined | null ? D : T;
/**
 * 树结构类型
 */
export type TreeDataItem<T extends string | number = string> = {
	value: T;
	label: string;
	children: TreeDataItem<T>;
};
/**
 *  树平铺结构类型
 */
export type TreeTiledDataItem<T extends string | number = string | number> = {
	value: T;
	label: string;
	parentValue?: T;
};
/**
 * 数组中的对象字段，转成label、value字段名对象，主要用于弹框中的数据源转换
 * @param dataList
 * @param fieldNames
 * @param isReserve 是否保留原字段，默认值：true
 * @returns
 * ```
 * 例如：[{ id: 1, name: '张三' }] => [{ id: 1, name: '张三', value: 1, label: '张三' }]
 * ```
 */
export declare const arrayField2LabelValue: (dataList: TPlainObject[], fieldNames?: {
	label?: string;
	value?: string;
}, isReserve?: boolean) => Array<LabelValueItem & {
	[key: string]: any;
}>;
/**
 * array.filter严谨查询，使用 === 进行比较
 * @param array
 * @param targetValue
 * @param fieldName 如果数组元素是对象，则为查找对象元素key值
 * @returns
 * ```
 * 例如：
 * 1. arrayFilter([1,2,3], 2) => [2]
 * 2. arrayFilter([{ age: 1, name: 'zhansan' },{ age: 2, name: 'lisi' },{ age: 3, name: 'wangwu' }], 2, 'age') => [{ age: 2,name: 'lisi' }]
 * ```
 */
export declare const arrayFilter: (dataList: TAny[], targetValue: string | number | boolean | undefined | null, fieldName?: string) => any[];
/**
 * array.filter不严谨查询，使用 == 进行比较
 * @param array
 * @param targetValue
 * @param fieldName 如果数组元素是对象，则为查找对象元素key值
 * ```
 * 例如：
 * 1. arrayFilterByLoosely([1,2,3], 2) => 2
 * 2. arrayFilterByLoosely([{ age: 1, name: 'zhansan' }], 1, 'age') => { age: 1, name: 'zhansan' }
 * 3. arrayFilterByLoosely([{ age: 1, name: 'zhansan' }], '1', 'age') => { age: 1, name: 'zhansan' }
 * ```
 */
export declare const arrayFilterByLoosely: (dataList: TAny[], targetValue: string | number | boolean | undefined | null, fieldName?: string) => any[];
/**
 * array.find严谨查询，使用 === 进行比较
 * @param array
 * @param targetValue
 * @param fieldName 如果数组元素是对象，则为查找对象元素key值
 * ```
 * 例如：
 * 1. arrayFind([1,2,3], 2) => 2
 * 2. arrayFind([{ age: 1, name: 'zhansan' }], 1, 'age') => { age: 1, name: 'zhansan' }
 * 3. arrayFind([{ age: 1, name: 'zhansan' }], '1', 'age', true) => { age: 1, name: 'zhansan' }
 * ```
 */
export declare const arrayFind: (dataList: TAny[], targetValue: string | number | boolean | undefined | null, fieldName?: string) => any;
/**
 * array.find不严谨查询，使用 == 进行比较
 * @param array
 * @param targetValue
 * @param fieldName 如果数组元素是对象，则为查找对象元素key值
 * ```
 * 例如：
 * 1. arrayFindByLoosely([1,2,3], 2) => 2
 * 2. arrayFindByLoosely([{ age: 1, name: 'zhansan' }], 1, 'age') => { age: 1, name: 'zhansan' }
 * 3. arrayFindByLoosely([{ age: 1, name: 'zhansan' }], '1', 'age') => { age: 1, name: 'zhansan' }
 * ```
 */
export declare const arrayFindByLoosely: (dataList: TAny[], targetValue: string | number | boolean | undefined | null, fieldName?: string) => any;
/**
 * array.findIndex严谨查询，使用 === 进行比较
 * ```
 * 使用 === 进行比较
 * ```
 * @param array
 * @param targetValue
 * @param fieldName 如果数组元素是对象，则为查找对象元素key值
 * ```
 * 例如：
 * 1. arrayFindIndex([1,2,3], 2) => 2
 * 2. arrayFindIndex([{ age: 1, name: 'zhansan' }], 1, 'age') => { age: 1, name: 'zhansan' }
 * 3. arrayFindIndex([{ age: 1, name: 'zhansan' }], '1', 'age', true) => { age: 1, name: 'zhansan' }
 * ```
 */
export declare const arrayFindIndex: (dataList: TAny[], targetValue: string | number | boolean | undefined | null, fieldName?: string) => number;
/**
 * array.findIndex不严谨查询，使用 == 进行比较
 * @param array
 * @param targetValue
 * @param fieldName 如果数组元素是对象，则为查找对象元素key值
 * ```
 * 例如：
 * 1. arrayFindIndex([1,2,3], 2) => 2
 * 2. arrayFindIndex([{ age: 1, name: 'zhansan' }], 1, 'age') => { age: 1, name: 'zhansan' }
 * 3. arrayFindIndex([{ age: 1, name: 'zhansan' }], '1', 'age', true) => { age: 1, name: 'zhansan' }
 * ```
 */
export declare const arrayFindIndexByLoosely: (dataList: TAny[], targetValue: string | number | boolean | undefined | null, fieldName?: string) => number;
/**
 * 数组中指定数值字段最大值
 * @param array
 * @param fieldKey 数值字段，如果数组项为Object
 * @returns
 */
export declare const arrayMax: (array: Array<TPlainObject | number>, fieldKey?: string) => number;
/**
 * 数组中指定数值字段最小值
 * @param array
 * @param fieldKey 数值字段，如果数组项为Object
 * @returns
 */
export declare const arrayMin: (array: Array<TPlainObject | number>, fieldKey?: string) => number;
/**
 * 根据条件在大数组中 挑选 出目标数据，严谨查询，使用 === 进行比较
 * @param array 大数组
 * @param targetValue 待挑选数据
 * @param fieldName 如果数组元素是对象，则为查找对象元素key值
 * ```
 * 例如：
 * 1. arrayPick([1,2,3], 2) => 2
 * 2. arrayPick([{ age: 1, name: 'zhansan' }], 1, 'age') => [{ age: 1, name: 'zhansan' }]
 * 3. arrayPick([{ age: 1, name: 'zhansan' }], '1', 'age') => []
 * ```
 */
export declare const arrayPick: (dataList: TAny[], targetValue: Array<string | number | boolean>, fieldName?: string) => any[];
/**
 * 根据条件在大数组中 挑选 出目标数据，不严谨查询，使用 == 进行比较
 * @param array 大数组
 * @param targetValue 待挑选数据
 * @param fieldName 如果数组元素是对象，则为查找对象元素key值
 * ```
 * 例如：
 * 1. arrayPickByLoosely([1,2,3], [2]) => [2]
 * 2. arrayPickByLoosely([{ age: 1, name: 'zhansan' }], [1], 'age') => [{ age: 1, name: 'zhansan' }]
 * 3. arrayPickByLoosely([{ age: 1, name: 'zhansan' }], ['1'], 'age') => [{ age: 1, name: 'zhansan' }]
 * ```
 */
export declare const arrayPickByLoosely: (dataList: TAny[], targetValue: Array<string | number | boolean>, fieldName?: string) => any[];
/**
 * 一维数组中两个元素交换位置
 * @param array
 * @param sourceIndex 来源索引
 * @param targetIndex 目标索引
 * ```
 * 1. sourceIndex、targetIndex超出array长度，数组不做任何处理
 * ```
 */
export declare const arrayReorder: (array: TAny[], sourceIndex: number, targetIndex: number) => any[];
/**
 * 二维数组中的两个元素变更位置
 * @param arrays 二位数组
 * @param source 来源元素信息 index: 操作元素所有，parentIndex：操作元素的一维数组索引
 * @param target 目标元素信息 index: 操作元素所有，parentIndex：操作元素的一维数组索引
 * @returns
 */
export declare const arraysReorder: (arrays: TAny[][], source: {
	index: number;
	parentIndex: number;
}, target: {
	index: number;
	parentIndex: number;
}) => any[][];
/**
 * 为数组添加uid唯一值字段
 * @param array 对象数组
 * @param options.uidKeyName uid字段名称，默认值：uid
 * @param options.returnNewArray 是否返回新数组，默认为false
 */
export declare const arraySetUid: (array: TPlainObject[], options?: {
	/** uid字段名称 */
	uidFieldName?: string;
	/** 是否返回新数组 */
	returnNewArray?: boolean;
}) => TPlainObject[];
/**
 * 分割数组
 * @param array
 * @param length 分割长度
 * @returns
 */
export declare const arraySplit: (array: TAny[], length: number) => any[][];
/**
 * 数组 转 键值对Map
 * ```
 * 例如：
 * [{ id: 1, name: '张三' }, { id: 2, name: '李四' }]
 * =>
 * { 1: { id: 1, name: '张三' }, 2: { id: 2, name: '李四' } }
 * ```
 */
export declare const arrayToMap: (dataList: TPlainObject[], uidName: string) => TPlainObject;
/**
 * 数组字段求和
 * @param array
 * @param fieldKey 求和字段，如果数组项为Object
 * @returns
 */
export declare const arrayTotal: (array: Array<TPlainObject | number>, fieldKey?: string) => number;
/**
 * 生成连续数字数组
 * @param from 连续数字起始值（包含）
 * @param to 连续数字结束值（不包含）
 * ```
 * generateIntArray(0, 5) => [0, 1, 2, 3, 4]
 * ```
 */
export declare function generateIntArray(from: number, to: number): number[];
/**
 * 是否为非空数组
 * ```
 * 结果true满足
 * 1. 必须为数组
 * 2. 数组长度大于0
 * ```
 */
export declare const isNotEmptyArray: (value: any) => boolean;
/**
 * 是否为空数组
 * ```
 * 结果true满足
 * 1. 必须为数组
 * 2. 数组为空
 * ```
 */
export declare const isEmptyArray: (value: any) => boolean;
/**
 * 通过规则字段 来源数组 并入 目标数组
 * @param sourceList 来源数组
 * @param targetList 目标数组
 * @param inRuleFieldName 匹配数组item相同的规则字段，默认值: value
 *
 * ```
 * listInList([{ value: 1, name: '张三', age: 100 }], [{ value: 1, age: 20, sex: 1 }], 'value')
 * =>
 * [{ value: 1, name: '张三', age: 20, sex: 1 }]
 * ```
 */
export declare const listInList: (sourceList: TPlainObject[], targetList: TPlainObject[], inRuleFieldName?: string) => TPlainObject[];
/**
 * 数组随机排序
 * @param array
 * @returns
 */
export declare const arrayRandomSort: <T>(array: T[]) => T[];
/**
 * 转数组
 * @param array
 * @returns
 * ```
 * 例如
 * 1. undefined or null => []
 * 2. [1,2,3] => [1,2,3]
 * 2. 任意其他数据A => [A]
 * ```
 */
export declare const toArray: <T>(value?: unknown) => T[];
/**
 * 两个数组中元素变换
 * ```
 * 1. sourceIndex、targetIndex超出长度，数组不做任何处理
 * ```
 */
export declare const twoArrayElementPositionChange: (sourceArray: TAny[], targetArray: TAny[], sourceIndex: number, targetIndex: number) => {
	sourceArray: any[];
	targetArray: any[];
};
export type DateFormatType = "YYYY-MM" | "YYYY-MM-DD" | "YYYY-MM-DD hh:mm" | "YYYY-MM-DD hh:mm:ss" | "MM-DD hh:mm:ss" | "MM-DD" | "YYYY/MM" | "YYYY/MM/DD" | "YYYY/MM/DD hh:mm" | "YYYY/MM/DD hh:mm:ss" | "MM/DD hh:mm:ss" | "MM/DD" | "YYYY.MM" | "YYYY.MM.DD" | "YYYY.MM.DD hh:mm" | "YYYY.MM.DD hh:mm:ss" | "MM.DD" | "YYYY\u5E74MM\u6708" | "YYYY\u5E74MM\u6708DD\u65E5" | "YYYY\u5E74MM\u6708DD\u65E5 hh:mm" | "YYYY\u5E74MM\u6708DD\u65E5 hh:mm:ss" | "MM\u6708DD\u65E5 hh:mm:ss" | "MM\u6708DD\u65E5" | "YYYYMM" | "YYYYMMDD" | "YYYYMMDD hh:mm" | "YYYYMMDD hh:mm:ss" | "MMDD hh:mm:ss" | "MMDD" | "hh:mm" | "hh:mm:ss";
export type DateType = Date | string | number;
declare const dateTimeGte: (date1: DateType, date2: DateType) => boolean;
declare const dateTimeGt: (date1: DateType, date2: DateType) => boolean;
declare const dateTimeEq: (date1: DateType, date2: DateType) => boolean;
declare const dateTimeIn: (targetDate: DateType, minDate: DateType, maxDate: DateType) => boolean;
declare const dateDetail: (dateInput: DateType) => {
	y: number;
	m: number;
	d: number;
	h: number;
	mi: number;
	s: number;
	ms: number;
	week: number;
	weekString: any;
	instance: Date;
};
declare const dateNew: (dateInput: DateType, mode: "y" | "m" | "d" | "h" | "mi" | "s", number: number) => Date;
declare const dateNormalize: (dateInput: DateType) => Date;
declare const dateFormat: (dateInput: DateType, format?: DateFormatType) => string;
declare const isDate: (dateInput: DateType) => boolean;
export type FlatbizDate = {
	/**
	 * 判断是否为合法日期
	 */
	isDate: typeof isDate;
	/**
	 * 日期格式化，默认格式：YYYY-MM-DD
	 */
	format: typeof dateFormat;
	/**
	 * 日期比较：大于等于
	 */
	gte: typeof dateTimeGte;
	/**
	 * 日期比较：大于
	 */
	gt: typeof dateTimeGt;
	/**
	 * 日期比较：等于
	 */
	eq: typeof dateTimeEq;
	/**
	 * 判断目标日期是否在指定区间内，包含临界值
	 * @param targetDate
	 * @param minDate
	 * @param maxDate
	 * ```
	 * 例如：targetDate e>= minDate && targetDate <= maxDate
	 * ```
	 */
	in: typeof dateTimeIn;
	/**
	 * 日期详情
	 * ```
	 * 1. 解析日期中的【'y' |'m' |'d' |'h' |'mi' |'s' |'ms' |'week'】数据
	 * 2. 解析后月份 1～12
	 * 3. 解析后星期 1～7
	 * ```
	 */
	detail: typeof dateDetail;
	/**
	 * 日期修改
	 * ```
	 * 对日期【'y' | 'm' | 'd' | 'h' | 'mi' | 's'】中进行加减值处理
	 * ```
	 */
	update: typeof dateNew;
	/**
	 * 指定数据转日期格式
	 */
	dateNormalize: typeof dateNormalize;
};
export declare const flatbizDate: FlatbizDate;
export type ScrollElement = HTMLElement | Window | Document;
declare function getScrollNode(el: Element, root?: ScrollElement | null | undefined): Element | Document | Window | null;
export interface BodyAppendDivElementProps {
	divElement: HTMLDivElement;
	elementId: string;
}
export declare const dom: {
	bodyAppendDivElement: (id?: string) => BodyAppendDivElementProps;
	createDivElement: (id?: string) => HTMLDivElement;
	removeBodyChild: (element: string) => void;
	/**
	 * 查询指定节点层层父节点中第一个原生滚动节点
	 * @param el
	 * @param root
	 * https://github.com/youzan/vant/issues/3823
	 */
	getScrollNode: typeof getScrollNode;
	/**
	 * 查找层层父节点中的目标元素
	 * @param originNode  起始节点
	 * @param verify 判断是否为目标节点
	 */
	findParentsElement: (originNode: HTMLElement | null, verify: (node: HTMLElement) => boolean) => HTMLElement | null;
};
export declare const base64ToFile: (dataurl: any, filename: any) => File;
export declare const fileToBase64: (file: File) => Promise<string>;
export type TImageCompressOptions = {
	/** 质量比例 0~1 */
	quality?: number;
	/** 图片宽高等比缩小 0~1 */
	ratio?: number;
	/**
	 * 压缩阀值（单位 MB）
	 * 小于阈值不压缩
	 */
	threshold?: number;
	/** 压缩后图片格式后缀，如果不设置，则根据图片原格式后缀 */
	suffix?: "jpg" | "png";
};
/**
 * 图片压缩
 * ```
 * 只支持 jpg、jpeg、png
 * quality：默认值 0.5
 * ratio: 默认值 1
 * threshold: 默认值 1
 * ```
 */
export declare const imageCompressToBase64: (imageFile: File, options?: TImageCompressOptions) => Promise<{
	base64: string;
	imageName: string;
	suffix: string;
}>;
/**
 * 图片压缩
 * ```
 * 只支持 jpg、jpeg、png
 * quality：默认值 0.5
 * ratio: 默认值 1
 * threshold: 默认值 1
 * ```
 */
export declare const imageCompressToFormData: (imageFile: File, formDataKey: string, options?: TImageCompressOptions) => Promise<unknown>;
/**
 * 图片压缩
 * ```
 * 只支持 jpg、jpeg、png
 * quality：默认值 0.5
 * ratio: 默认值 1
 * threshold: 默认值 1
 * ```
 */
export declare const imageCompressToFile: (imageFile: File, options?: TImageCompressOptions) => File | Promise<File>;
/**
 * 是否为空
 * ```
 * value === undefined || value === null;
 * ```
 */
export declare const isUndefinedOrNull: (value: any) => boolean;
export declare const noop: () => void;
/**
 * 判断是否为数字（包括字符串数字）
 * ```
 * isNumber(123) // true
 * isNumber('123') // true
 * isNumber('123a') // false
 * isNumber(undefined) // false
 * isNumber(null) // false
 * isNumber('') // false
 * ```
 */
export declare const isNumber: (num: string | number) => boolean;
/**
 * 深拷贝对象，对象中只能存在 JSON 支持的类型
 * ```
 * 例如
 * 1. cloneObject({ x: 1 })
 * 2. cloneObject([{ x: 1 }])
 * ```
 */
export declare const cloneObject: <T extends object>(obj: T) => T;
/**
 * 获取枚举类型 value 数组
 * @param enumeration 枚举类型
 * @returns
 * ```
 * 例如：
 * enum AdminTypeEnum {
 *  superAdmin = 1,
 *  generalAdmin = 0,
 * }
 * =>
 * [1,0]
 * ```
 */
export declare const enumValues: <T extends object>(enumeration: T) => Array<T[keyof T]>;
export type MapToListDefaultItem<V> = {
	label: string;
	value: V;
};
/**
 * 对象转数组（精确）
 * @param mapData map对象
 * @param valueList value数组
 * @param labelName 自定义map key值属性名称，默认：value
 * @param valueName 自定义map value值属性名称，默认：label
 * @returns
 * ```
 * 由于map对象再获取key列表时，都是字符串类型数组，无法精确获取key类型，所以通过valueList来获取key的精确类型
 * const adminTypeMap = {
 *    1:'superAdmin',
 *    2:'generalAdmin',
 * }
 * mapToListExact<MapToListDefaultItem<number>>(adminTypeMap, [1,2])
 * =>
 * 默认值转出格式
 * [{ label: 'superAdmin', value: 1 },{ label: 'generalAdmin', value: 2 }]
 * ```
 */
export declare const mapToListExact: <T extends object>(mapData: Record<string, unknown>, valueList: Array<string | number>, labelName?: string, valueName?: string, colorMap?: Record<string | number, string>) => T[];
/**
 * 对象转数组（非精确转换，精确转换使用mapToListExact）
 * @param map 对象
 * @param labelName 自定义map key值属性名称，默认：value
 * @param valueName 自定义map value值属性名称，默认：label
 * @returns
 * ```
 * 例如
 * const adminType = {
 *    1:'superAdmin',
 *    2:'generalAdmin',
 * }
 * mapToListExact<MapToListDefaultItem<number>>(adminType, [1,2])
 * =>
 * 默认值转出格式
 * [{ label: 'superAdmin', value: '1' },{ label: 'generalAdmin', value: '2' }]
 * ```
 */
export declare const mapToList: <T extends object>(map: Record<string, unknown>, labelName?: string, valueName?: string) => T[];
/**
 * 从对象数据中，根据规则筛选对象
 * @param data
 * @param keyList
 * @returns
 *
 */
export declare const objectGetObject: (objectData?: TPlainObject, keyList?: Array<string | {
	beforeKey: string;
	afterKey: string;
}>) => TPlainObject;
export declare const polyfill: () => void;
declare const add: (amt: string | number, amt2: string | number, option?: PriceOption) => number;
declare const subtract: (amt: string | number, amt2: string | number, option?: PriceOption) => number;
declare const multiply: (amt: string | number, amt2: string | number, option?: PriceOption) => number;
declare const divide: (amt: string | number, amt2: string | number, option?: PriceOption) => number;
declare const priceFen2wan: (amt?: string | number, defaultValue?: string | number) => string | number;
declare const priceFen2yuan: (amt?: string | number, defaultValue?: string | number) => string | number;
declare const priceFormat: (amt?: string | number, defaultValue?: string | number, options?: {
	/** 是否显示分隔符，默认值：true */
	separator?: boolean;
	/** 小数点后位数，默认：2 */
	precision?: number;
}) => string;
declare const priceRemoveTailZero: (amt?: string | number, defaultValue?: string | number, options?: {
	/** 是否显示分隔符，默认值：true */
	separator: boolean;
}) => string;
declare const priceSplit: (amt?: string | number, defaultValue?: string | number, options?: {
	/** 是否显示分隔符，默认值：true */
	separator?: boolean;
	/** 小数点后位数，默认：2 */
	precision?: number;
}) => string[];
declare const priceWan2fen: (amt?: string | number, defaultValue?: string | number) => string | number;
declare const priceYuan2fen: (amt?: string | number, defaultValue?: string | number) => string | number;
export type FlatbizPrice = {
	/**
	 * 金额转换 分 => 元
	 */
	fen2yuan: typeof priceFen2yuan;
	/**
	 * 金额转换  元 => 分
	 */
	yuan2fen: typeof priceYuan2fen;
	/**
	 * 金额转换 分 => 万
	 */
	fen2wan: typeof priceFen2wan;
	/**
	 * 金额转换  万 => 分
	 */
	wan2fen: typeof priceWan2fen;
	/**
	 * 金额小数点尾号去零
	 * ```
	 * 例如：
	 * 19.90 => 19.9
	 * 19.00 => 19
	 * ```
	 */
	removeTailZero: typeof priceRemoveTailZero;
	/**
	 * 格式化金额保留小数点后2位
	 */
	format: typeof priceFormat;
	/**
	 * 金额分割
	 * ```
	 * 例如：
	 * 19.09 => ['19', '.09']
	 * 99.00 => ['99', '.00']
	 * ```
	 */
	split: typeof priceSplit;
	/**
	 * 金额计算：加
	 */
	add: typeof add;
	/**
	 * 金额计算：减
	 */
	subtract: typeof subtract;
	/**
	 * 金额计算：乘
	 */
	multiply: typeof multiply;
	/**
	 * 金额计算：除
	 */
	divide: typeof divide;
};
export declare const flatbizPrice: FlatbizPrice;
export declare function attachPropertiesToComponent<C, P extends Record<string, unknown>>(component: C, properties: P): C & P;
/**
 * 合并执行 originProps、patchProps中存在的相同命名函数，
 * @param originProps 原对象数据
 * @param patchProps 补丁对象数据
 * @param isMerge 是否浅合并对象，默认值：true
 * ```
 * 1. 主要用于 react 组件函数合并
 * ```
 */
export declare const composeProps: <T extends Record<string, TAny>, P extends Record<string, TAny>>(originProps: T, patchProps: P, isMerge?: boolean) => T & P;
/**
 * 延迟
 * @param time 毫米
 * @returns
 */
export declare const sleep: (time: number) => Promise<unknown>;
/**
 * 获取字符串字节长度
 * @param str
 * @returns
 */
export declare const getStrByteLen: (str: string) => number;
/**
 * 根据字节长度截取字符串
 * @param str
 * @param bytes
 * @returns
 */
export declare const subStringByBytes: (str: string, bytes: number) => string;
/**
 * 根据[字节长度]来截取字符串
 * @param str 待截取字符数据
 * @param len 截取字节长度
 * @param flow 溢出符，默认...
 */
export declare const cutString: (str: string, bytes: number, flow?: string) => string;
/**
 * 字符串格式化
 * @param value 字符串
 * @param format 格式化间隙
 * @returns
 * ```
 * format('18512345678', [3, 4, 4]) => ['185', '1234', '5678']
 * format('18512345678', [3, 2]) => ['185', '12', '345678']
 * format('18512345678', [3, 20]) => ['185', '12345678']
 * format('18512345678', []) => ['18512345678']
 * ```
 */
export declare const stringFormat: (value: string, format: number[]) => string[];
/**
 * 获取 value，如果为undefined、null，则返回 defaultValue
 * ```
 * 1. getValueOrDefault(undefined, '-') => '-'
 * 2. getValueOrDefault(0, '-') => 0
 * ```
 */
export declare const getValueOrDefault: (value: TAny, defaultValue: TAny) => any;
/**
 * json string 转 json 对象
 * ```
 * 非json字符串会抛异常
 * ```
 */
export declare const jsonStringToJsonObject: (jsonString: string) => never;
/**
 * 清除空格，可清除前后空格或所有空格
 * @param str
 * @param cancelGlobal 取消所有，只清除前后空格
 */
export declare const trim: (str: string, cancelGlobal?: boolean) => string;
export declare const getUuid: () => string;
/**
 * 两个值比较，只用于string、number类型的值比较
 * @param firstValue string、number
 * @param secondValue string、number、Array<string | number>
 * @returns
 * ```
 * 1. 不用区分具体是string还是number
 * 2. secondValue为数组时，firstValue只要和数组中的任意值相等，即返回true
 * ```
 */
export declare const valueIsEqual: (firstValue?: string | number | boolean, secondValue?: string | number | boolean | Array<string | number | boolean>) => boolean;
/**
 * 验证xml格式的正确性
 * ```
 *  result / true 验证通过
 *  result / false 验证不通过，message为失败描述
 * ```
 */
export declare const xmlValidate: (xmlContent: string) => {
	message: any;
	result: boolean;
};
export declare const localStorageCache: {
	set: (key: string, value: Record<string, unknown>) => void;
	get: (key: string) => Record<string, unknown>;
	remove: (key: string) => void;
};
export declare const sessionStorageCache: {
	set: (key: string, value: Record<string, unknown>) => void;
	get: (key: string) => Record<string, unknown>;
	remove: (key: string) => void;
};
export declare const isMockMeEnv: () => boolean;
export declare const isMockDevEnv: () => boolean;
/** 是否为mac系统（包含iphone手机） */
export declare const isMacEnv: () => boolean;
/** 是否为windows系统 */
export declare const isWindowsEnv: () => boolean;
/**
 * Mozilla/5.0 (Linux; Android 8.0.0; ALP-AL00 Build/HUAWEIALP-AL00; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/63.0.3239.111 Mobile Safari/537.36/TcFinancial/9.01.06
 * return webview userAgent string.
 */
export declare const userAgent: () => string;
/**
 * Check if device is iphone, ipad.
 * @param ua client webview userAgent
 */
export declare const isIphone: () => boolean;
export declare const isMac: () => boolean;
export declare const isIphoneOrMac: () => boolean;
/**
 * Check if device is android.
 * @param ua client webview userAgent
 */
export declare const isAndroid: () => boolean;
/**
 * 判断当前是否是fabric webview, 拥有插件调用能力
 * Mozilla/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.3 Mobile/15E148 Safari/604.1 Fabric@inhome/1.0.0 Fabric/NoWebview
 * Fabric容器标识 `Fabric@inhome/1.0.0`
 * Fabric容器下通过?ntv_history打开的多一个标识 `Fabric/DisableWebview`注意此标识必须在应用级注入禁用标识, 并且不能随意改变策略, 否则定会出现兼容性问题.
 * @param ua
 */
export declare const isFabricWebview: (ua?: string) => boolean;
export declare const getGlobalData: <T>() => T;
export declare const getWindow: <T>(key: string) => T;
export declare const setWindow: (data: TPlainObject) => void;
/**
 * Web浏览器打开新窗口，替代window.open
 * ```
 * 直接使用window.open会被浏览器拦截
 * ```
 */
export declare const openNewWindow: (url: string) => void;
/**
 * 表格合并单元格计算
 *```
 * 操作字段包括合并字段、统计字段
 * 1. 合并字段用于计算单元格合并的格数
 * 2. 统计字段用于统计数值（数字类型），必须依赖于合并字段
 *
 * 计算完成后会在数据中添加部分字段
 * 1. 设置mergeFields mergeKey数组后，会在每一条数据中添加 [mergeKey]RowSpan合并单元格数量字段
 * 2. 设置mergeFields statisticKey后，会在数据中添加 [mergeKey]RowTotal统计字段
 *
 * 写法1：不存在统计字段
 *  tableMergeCellCalculate([], ['key1', 'key2'])
 * 写法2：存在统计字段
 *  tableMergeCellCalculate([], [{ mergeKey: 'key1' }, { mergeKey: 'key2', statisticKey: 'key3' }])
 *
 * demo： https://fex.qa.tcshuke.com/docs/admin/main/table/cell-merge
 *
 *```
 */
export declare const tableMergeCellCalculate: (dataSource: TPlainObject[], mergeFields: string[] | {
	/** 合并字段 */
	mergeKey: string;
	/** 统计字段 */
	statisticKey?: string;
}[], pagination?: {
	pageNo: number;
	pageSize: number;
}) => TPlainObject[];
/**
 * 由平铺数组转为树数组
 */
export declare const tiledArrayToTree: (dataList: TPlainObject[], fieldNames: {
	idKeyName: string;
	pIdKeyName: string;
	childrenKeyName: string;
}, isRootNode: (dataItem: TPlainObject) => boolean) => TPlainObject[];
/**
 * 树结构数据递归遍历适配
 * ```
 * 1. adaptive 适配器，可在返回值添加新字段数据
 * 2. childrenName tree结构数据children字段名称，默认值：children
 * ```
 */
export declare const treeEachAdaptive: (treeDataList: TPlainObject[], adaptive: (data: TPlainObject) => TPlainObject, childrenName?: string) => TPlainObject[];
/**
 * 树结构数据，复制字段数据为新字段值（配置方式）
 * ```
 * 1. changeFieldNames => { '原字段': '新字段' }，原字段与新字段同时存在
 * 2. childrenName tree结构数据children字段名称，默认值：children
 * ```
 */
export declare const treeFieldNameChange: (treeList: TPlainObject[], changeFieldNames: TPlainObject<string>, childrenName?: string) => TPlainObject[];
/**
 * 树结构数据，复制字段数据为新字段值（适配器方式）
 * ```
 * 1. treeItemAdapter 适配器，可在返回值添加新字段数据
 * 2. childrenName tree结构数据children字段名称，默认值：children
 * ```
 */
export declare const treeFieldNameChangeAdapter: (treeList: TPlainObject[], treeItemAdapter: (treeItem: TPlainObject) => TPlainObject, childrenName?: string) => TPlainObject[];
/**
 * 根据规则过滤tree数据
 * @param dataList tree 数据
 * @param filter 过滤条件 返回false 移除
 * @param options 配置项
 *
 * ```
 *  options配置项目中
 * 1. options.childrenName（tree数据数组节点key字段名称）
 *    默认值：children
 * 2. options.queryParentShowChildrenAll（过滤匹配到父节点是否显示全部子节点，默认值：true）
 *    true：匹配到父节点，则显示全部子节点
 *    false：未匹配到父节点，则移除所有子节点
 * ```
 */
export declare const treeFilter: (dataList: TPlainObject[], filter: (node: any) => boolean, options?: {
	childrenName?: string;
	/** 过滤匹配到父节点是否显示全部子节点，默认：true */
	queryParentShowChildrenAll?: boolean;
}) => TPlainObject[];
/**
 * 根据key值 删除 Tree数据节点以及所有子节点
 * @param key 待删除节点 key
 * @param treeList tree 数据
 * @param options tree 数据字段名称配置
 *
 */
export declare const treeItemDelete: (key: string | number, treeList: TPlainObject[], options: {
	key: string;
	children: string;
}) => TPlainObject[];
/**
 * 通过过滤器删除树形数据中的节点
 * @param treeList 树形数据
 * @param filter 过滤器 返回true 删除节点
 * @param childrenName
 *
 */
export declare const treeItemDeleteByFilter: (treeList: TPlainObject[], filter: (node: TPlainObject) => boolean, childrenName?: string) => TPlainObject[];
/**
 * 树叶子节点的所有父节点列表
 * @deprecated 已过期，请使用 treeNodeParentsList 方法（入参中列表数据有区别，注意区分）
 * @param value 叶子节点值
 * @param treeTiledList 平铺树结构，可通过treeToArray 将tree数据转为tree平铺数据
 * @param hasSelf 返回是否包含叶子节点，默认值：false
 * @param fieldNames 字段配置，默认值 { value: 'value', parentValue: 'parentValue' }
 * ```
 * fieldNames.parentValue 可传多级，例如: 'parent.id'
 * ```
 */
export declare const treeLeafParentsArray: (value: string | number, treeTiledList: TPlainObject[], hasSelf?: boolean, fieldNames?: {
	value: string;
	parentValue: string;
}) => TPlainObject[];
/**
 * 指定节点的所有父节点列表
 * @param value 叶子节点值
 * @param treeDataList 树结构数据
 * @param hasSelf 返回是否包含叶子节点，默认值：false
 * @param fieldNames 字段配置，默认值 { value: 'value', children: 'children' }
 * ```
 * 注意：树结构数据中节点value必须唯一不重复
 * ```
 */
export declare const treeNodeParentsList: (value: string | number, treeDataList: TPlainObject[], hasSelf?: boolean, fieldNames?: {
	value: string;
	children: string;
}) => (string | number)[];
/**
 * 树结构数据，由嵌套结构转成平铺结构，返回值不改变原数据命名
 * @param dataList
 * @param childrenName
 * @param insertPId pId字段设置，设置后树结构转为平铺结构时，会添加父子链路pId
 */
export declare const treeToArray: (treeDataList: TPlainObject[], childrenName: string, insertPId?: {
	idName: string;
	pIdKeyName: string;
}) => TPlainObject[];
/**
 * 树结构数据，由嵌套结构转成平铺结构，返回数据格式根据fieldNames转换成 { value, label, parentValue }
 * @param dataList
 * @param fieldNames
 * @returns
 */
export declare const treeToTiledArray: (dataList: TPlainObject[], fieldNames?: {
	label?: string;
	value?: string;
	children?: string;
}) => (TreeTiledDataItem & {
	[key: string]: any;
})[];
/**
 * 树结构数据，由嵌套结构转成平铺【键值对】
 * @param treeDataList tree对象，数据中必须要有唯一值
 * @param fieldNames.value 数组对象中的唯一值
 * @param fieldNames.children 默认值：children
 * @param insertPIdKeyName pId字段名称，设置后树结构转为平铺结构时，会添加父子链路pId
 *
 *```
 * 例如：
 * [{ id: 1, name: '张三' }, { id: 2, name: '李四', chidren: [{ id: 3, name: '李四儿子', }] }]
 * =>
 * { 1: { id: 1, name: '张三' }, 2: { id: 2, name: '李四' }, 3: { id: 3, name: '李四儿子' } }
 * ```
 */
export declare const treeToTiledMap: (treeDataList: TPlainObject[], fieldNames: {
	value: string;
	children: string;
}, insertPIdFieldName?: string) => TPlainObject;
/**
 * 字符串前后斜线，拼接和取消
 * @param str
 * @param slashFix 默认值 true
 * @returns
 * ```
 * 例如：
 * 1. ensureSlash('/abc', true) => /abc/
 * 2. ensureSlash('abc', true) => /abc/
 * 3. ensureSlash('/abc/', false) => abc
 * ```
 *
 */
export declare const ensureSlash: (str: string, slashFix?: boolean) => string;
/**
 * 获取指定项目模块地址
 * @param module
 */
export declare const getModuleUrl: (module: string, query?: TPlainObject) => string;
export declare const isHttpUri: (uri: string) => boolean;
/**
 * 比较两个path是否相等
 * @param targetPath 目标path
 * @param comparedPath 被比较path
 * @returns
 */
export declare const pathEqual: (targetPath: string, comparedPath: string) => boolean;
/**
 * 比较comparedPath是否包含targetPath
 * @param targetPath 目标path
 * @param comparedPath 被比较path
 * @returns
 */
export declare const pathEqualInclude: (targetPath: string, comparedPath: string) => boolean;
/**
 * 移除字符串前后斜线
 * @param str
 * @param position
 * @returns
 * ```
 * 例如：
 * 1. removeSlash('/abc', 'before') => abc
 * 2. removeSlash('/abc/', 'after') => /abc
 * 3. removeSlash('/abc/', 'before-after') => abc
 * ```
 *
 */
export declare const removeSlash: (str: string, position: "before" | "after" | "before-after") => string;
/**
 * 根据当前地址协议，获取完整的url地址
 * ```
 * 例如
 * //xxx.com => https://xxx.com
 * ```
 */
export declare const toFullPath: (url: string) => string;
/**
 * 向path中拼接query数据，内部项目使用
 * ```
 * 1.默认query值
 *  1). env 非生产环境有效
 *  2). fabric-callback-key【webview通信key值】
 *  3). accessToken【env=me环境下有效】
 *  4). 业务流程参数 window.bizProcessUrlParam 配置的key值
 * 2.query中undefined会被过滤
 * ```
 */
export declare const toLinkPath: (path: string, query?: TPlainObject) => string;
export declare const toLinkPathWithQuery: (path: string, query?: TPlainObject) => string;
export declare const urlJoin: (first: string, second: string) => string;
/**
 * url片段拼接
 * @param first
 * @param second
 * @returns
 */
export declare const urlJoinMulti: (firstUrl: string, ...fragment: string[]) => string;
export declare const getUrlRoute: (url: string) => string;
export declare const is18IdCard: (sId: string) => boolean;
export declare const flatbizRegExp: {
	/** 汉字格式  */
	chineseCharactersRegExp: RegExp;
	/** 手机号格式  */
	mobileRegExp: RegExp;
	/** 正整数格式 */
	integerRegExp: RegExp;
	/** 金额格式  */
	amountRegExp: RegExp;
	/** 密码格式：英文大小写、数字、符号[!@#$%^&*?.]其中两种及以上，长度8-20位 */
	passwordRegExp: RegExp;
	/** 8-20位数字和字母的组合 */
	passwordRegExp2: RegExp;
};

export {};
