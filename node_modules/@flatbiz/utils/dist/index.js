/*! @flatjs/forge MIT @flatbiz/utils */

import { extend } from '@dimjs/utils/extend/extend';
import { isNumber as isNumber$1 } from '@dimjs/lang/is-number';
import { isPlainObject } from '@dimjs/lang/is-plain-object';
import { arrayRemove } from '@dimjs/utils/array/array-remove';
import { cache } from '@dimjs/utils/cache/cache';
import { isArray } from '@dimjs/lang/is-array';
import { dateNormalize as dateNormalize$1 } from '@dimjs/utils/date/date-normalize';
import { dateNew as dateNew$1 } from '@dimjs/utils/date/date-new';
import { dateFormat as dateFormat$1 } from '@dimjs/utils/date/date-format';
import { price } from '@dimjs/utils/price/price';
import { isUndefined } from '@dimjs/lang/is-undefined';
import { isString } from '@dimjs/lang/is-string';
import { getQueryString } from '@dimjs/utils/uri/get-query-string';
import { get } from '@dimjs/utils/get/get';
import { modifyQueryString } from '@dimjs/utils/uri/modify-query-string';
import { isHttpUrl } from '@dimjs/utils/uri/is-http-url';
import { paramStrToJson } from '@dimjs/utils/uri/param-str-to-json';
import { uriParse } from '@dimjs/utils/uri/uri-parse';

/**
 * 是否为空
 * ```
 * value === undefined || value === null;
 * ```
 */
const isUndefinedOrNull = value => {
  return value === undefined || value === null;
};

/**
 * 数组中的对象字段，转成label、value字段名对象，主要用于弹框中的数据源转换
 * @param dataList
 * @param fieldNames
 * @param isReserve 是否保留原字段，默认值：true
 * @returns
 * ```
 * 例如：[{ id: 1, name: '张三' }] => [{ id: 1, name: '张三', value: 1, label: '张三' }]
 * ```
 */
const arrayField2LabelValue = (dataList, fieldNames, isReserve) => {
  const dataListNew = dataList || [];
  const fieldNamesNew = extend({
    label: 'label',
    value: 'value'
  }, fieldNames);
  const isReserveNew = isUndefinedOrNull(isReserve) ? true : isReserve;
  return dataListNew.map(item => {
    let respData = {
      label: item[fieldNamesNew.label],
      value: item[fieldNamesNew.value]
    };
    if (isReserveNew) {
      respData = extend({}, item, respData);
    }
    return respData;
  });
};

/**
 * array.filter严谨查询，使用 === 进行比较
 * @param array
 * @param targetValue
 * @param fieldName 如果数组元素是对象，则为查找对象元素key值
 * @returns
 * ```
 * 例如：
 * 1. arrayFilter([1,2,3], 2) => [2]
 * 2. arrayFilter([{ age: 1, name: 'zhansan' },{ age: 2, name: 'lisi' },{ age: 3, name: 'wangwu' }], 2, 'age') => [{ age: 2,name: 'lisi' }]
 * ```
 */
const arrayFilter = (dataList, targetValue, fieldName) => {
  const dataListNew = dataList || [];
  if (!fieldName) {
    return dataListNew.filter(item => {
      return item === targetValue;
    });
  }
  return dataListNew.filter(item => {
    return item?.[fieldName] === targetValue;
  });
};

/**
 * array.filter不严谨查询，使用 == 进行比较
 * @param array
 * @param targetValue
 * @param fieldName 如果数组元素是对象，则为查找对象元素key值
 * ```
 * 例如：
 * 1. arrayFilterByLoosely([1,2,3], 2) => 2
 * 2. arrayFilterByLoosely([{ age: 1, name: 'zhansan' }], 1, 'age') => { age: 1, name: 'zhansan' }
 * 3. arrayFilterByLoosely([{ age: 1, name: 'zhansan' }], '1', 'age') => { age: 1, name: 'zhansan' }
 * ```
 */
const arrayFilterByLoosely = (dataList, targetValue, fieldName) => {
  const dataListNew = dataList || [];
  if (!fieldName) {
    return dataListNew.filter(item => {
      return item == targetValue;
    });
  }
  return dataListNew.filter(item => {
    return item?.[fieldName] == targetValue;
  });
};

/**
 * array.find严谨查询，使用 === 进行比较
 * @param array
 * @param targetValue
 * @param fieldName 如果数组元素是对象，则为查找对象元素key值
 * ```
 * 例如：
 * 1. arrayFind([1,2,3], 2) => 2
 * 2. arrayFind([{ age: 1, name: 'zhansan' }], 1, 'age') => { age: 1, name: 'zhansan' }
 * 3. arrayFind([{ age: 1, name: 'zhansan' }], '1', 'age', true) => { age: 1, name: 'zhansan' }
 * ```
 */
const arrayFind = (dataList, targetValue, fieldName) => {
  const dataListNew = dataList || [];
  if (!fieldName) {
    return dataListNew.find(item => {
      return item === targetValue;
    });
  }
  return dataListNew.find(item => {
    return item[fieldName] === targetValue;
  });
};

/**
 * array.find不严谨查询，使用 == 进行比较
 * @param array
 * @param targetValue
 * @param fieldName 如果数组元素是对象，则为查找对象元素key值
 * ```
 * 例如：
 * 1. arrayFindByLoosely([1,2,3], 2) => 2
 * 2. arrayFindByLoosely([{ age: 1, name: 'zhansan' }], 1, 'age') => { age: 1, name: 'zhansan' }
 * 3. arrayFindByLoosely([{ age: 1, name: 'zhansan' }], '1', 'age') => { age: 1, name: 'zhansan' }
 * ```
 */
const arrayFindByLoosely = (dataList, targetValue, fieldName) => {
  const dataListNew = dataList || [];
  if (!fieldName) {
    return dataListNew.find(item => {
      return item == targetValue;
    });
  }
  return dataListNew.find(item => {
    return item[fieldName] == targetValue;
  });
};

/**
 * array.findIndex严谨查询，使用 === 进行比较
 * ```
 * 使用 === 进行比较
 * ```
 * @param array
 * @param targetValue
 * @param fieldName 如果数组元素是对象，则为查找对象元素key值
 * ```
 * 例如：
 * 1. arrayFindIndex([1,2,3], 2) => 2
 * 2. arrayFindIndex([{ age: 1, name: 'zhansan' }], 1, 'age') => { age: 1, name: 'zhansan' }
 * 3. arrayFindIndex([{ age: 1, name: 'zhansan' }], '1', 'age', true) => { age: 1, name: 'zhansan' }
 * ```
 */
const arrayFindIndex = (dataList, targetValue, fieldName) => {
  const dataListNew = dataList || [];
  if (!fieldName) {
    return dataListNew.findIndex(item => {
      return item === targetValue;
    });
  }
  return dataListNew.findIndex(item => {
    return item[fieldName] === targetValue;
  });
};

/**
 * array.findIndex不严谨查询，使用 == 进行比较
 * @param array
 * @param targetValue
 * @param fieldName 如果数组元素是对象，则为查找对象元素key值
 * ```
 * 例如：
 * 1. arrayFindIndex([1,2,3], 2) => 2
 * 2. arrayFindIndex([{ age: 1, name: 'zhansan' }], 1, 'age') => { age: 1, name: 'zhansan' }
 * 3. arrayFindIndex([{ age: 1, name: 'zhansan' }], '1', 'age', true) => { age: 1, name: 'zhansan' }
 * ```
 */
const arrayFindIndexByLoosely = (dataList, targetValue, fieldName) => {
  const dataListNew = dataList || [];
  if (!fieldName) {
    return dataListNew.findIndex(item => {
      return item == targetValue;
    });
  }
  return dataListNew.findIndex(item => {
    return item[fieldName] == targetValue;
  });
};

/**
 * 数组中指定数值字段最大值
 * @param array
 * @param fieldKey 数值字段，如果数组项为Object
 * @returns
 */
const arrayMax = (array, fieldKey) => {
  let max;
  array.forEach(item => {
    let itemValue = item;
    if (isPlainObject(item) && fieldKey && isNumber$1(item[fieldKey])) {
      itemValue = item[fieldKey];
    }
    if (!max) max = itemValue;
    max = itemValue > max ? itemValue : max;
  });
  return max;
};

/**
 * 数组中指定数值字段最小值
 * @param array
 * @param fieldKey 数值字段，如果数组项为Object
 * @returns
 */
const arrayMin = (array, fieldKey) => {
  let min;
  array.forEach(item => {
    let itemValue = item;
    if (isPlainObject(item) && fieldKey && isNumber$1(item[fieldKey])) {
      itemValue = item[fieldKey];
    }
    if (!min) min = itemValue;
    min = itemValue < min ? itemValue : min;
  });
  return min;
};

/**
 * 根据条件在大数组中 挑选 出目标数据，严谨查询，使用 === 进行比较
 * @param array 大数组
 * @param targetValue 待挑选数据
 * @param fieldName 如果数组元素是对象，则为查找对象元素key值
 * ```
 * 例如：
 * 1. arrayPick([1,2,3], 2) => 2
 * 2. arrayPick([{ age: 1, name: 'zhansan' }], 1, 'age') => [{ age: 1, name: 'zhansan' }]
 * 3. arrayPick([{ age: 1, name: 'zhansan' }], '1', 'age') => []
 * ```
 */
const arrayPick = (dataList, targetValue, fieldName) => {
  const dataListNew = dataList || [];
  let result = [];
  targetValue.forEach(value => {
    const target = arrayFilter(dataListNew, value, fieldName);
    if (target) {
      result = result.concat(target);
    }
  });
  return result;
};

/**
 * 根据条件在大数组中 挑选 出目标数据，不严谨查询，使用 == 进行比较
 * @param array 大数组
 * @param targetValue 待挑选数据
 * @param fieldName 如果数组元素是对象，则为查找对象元素key值
 * ```
 * 例如：
 * 1. arrayPickByLoosely([1,2,3], [2]) => [2]
 * 2. arrayPickByLoosely([{ age: 1, name: 'zhansan' }], [1], 'age') => [{ age: 1, name: 'zhansan' }]
 * 3. arrayPickByLoosely([{ age: 1, name: 'zhansan' }], ['1'], 'age') => [{ age: 1, name: 'zhansan' }]
 * ```
 */
const arrayPickByLoosely = (dataList, targetValue, fieldName) => {
  const dataListNew = dataList || [];
  let result = [];
  targetValue.forEach(value => {
    const target = arrayFilterByLoosely(dataListNew, value, fieldName);
    if (target) {
      result = result.concat(target);
    }
  });
  return result;
};

/**
 * 一维数组中两个元素交换位置
 * @param array
 * @param sourceIndex 来源索引
 * @param targetIndex 目标索引
 * ```
 * 1. sourceIndex、targetIndex超出array长度，数组不做任何处理
 * ```
 */
const arrayReorder = (array, sourceIndex, targetIndex) => {
  const result = Array.from(array);
  if (sourceIndex > array.length - 1 || targetIndex > array.length - 1) {
    console.warn('指定交换索引值超出数组长度');
    return array;
  }
  //删除并记录 删除元素
  const [removed] = result.splice(sourceIndex, 1);
  //将原来的元素添加进数组
  result.splice(targetIndex, 0, removed);
  return result;
};

/**
 * 二维数组中的两个元素变更位置
 * @param arrays 二位数组
 * @param source 来源元素信息 index: 操作元素所有，parentIndex：操作元素的一维数组索引
 * @param target 目标元素信息 index: 操作元素所有，parentIndex：操作元素的一维数组索引
 * @returns
 */
const arraysReorder = (arrays, source, target) => {
  const sourceItems = arrays[source.parentIndex];
  const sourceTarget = sourceItems[source.index];
  const sourceItemsNew = arrayRemove(sourceItems, sourceTarget);
  arrays[source.parentIndex] = sourceItemsNew;
  const targetItems = arrays[target.parentIndex];
  const newOverItems = [...targetItems.slice(0, target.index), sourceTarget, ...targetItems.slice(target.index, targetItems.length)];
  arrays[target.parentIndex] = newOverItems;
  return arrays;
};

/**
 * 深拷贝对象，对象中只能存在 JSON 支持的类型
 * ```
 * 例如
 * 1. cloneObject({ x: 1 })
 * 2. cloneObject([{ x: 1 }])
 * ```
 */
const cloneObject = obj => {
  return JSON.parse(JSON.stringify(obj));
};

const uuidFactory = (() => {
  const now = `${Date.now()}`;
  return cache(`uuid-${now.substring(now.length - 4, now.length)}-`, 100);
})();
const getUuid = () => {
  return uuidFactory();
};

/**
 * 为数组添加uid唯一值字段
 * @param array 对象数组
 * @param options.uidKeyName uid字段名称，默认值：uid
 * @param options.returnNewArray 是否返回新数组，默认为false
 */
const arraySetUid = (array, options) => {
  const uidFieldNameFt = options?.uidFieldName || 'uid';
  const arrayFt = options?.returnNewArray ? cloneObject(array) : array;
  arrayFt.forEach(item => {
    item[uidFieldNameFt] = getUuid();
  });
  return arrayFt;
};

/**
 * 分割数组
 * @param array
 * @param length 分割长度
 * @returns
 */
const arraySplit = (array, length) => {
  if (length <= 0) return [];
  let index = 0;
  const newArray = [];
  while (index < array.length) {
    newArray.push(array.slice(index, index += length));
  }
  return newArray;
};

/**
 * 数组 转 键值对Map
 * ```
 * 例如：
 * [{ id: 1, name: '张三' }, { id: 2, name: '李四' }]
 * =>
 * { 1: { id: 1, name: '张三' }, 2: { id: 2, name: '李四' } }
 * ```
 */
const arrayToMap = (dataList, uidName) => {
  const result = {};
  dataList.forEach(item => {
    result[item[uidName]] = item;
  });
  return result;
};

/**
 * 数组字段求和
 * @param array
 * @param fieldKey 求和字段，如果数组项为Object
 * @returns
 */
const arrayTotal = (array, fieldKey) => {
  let total = 0;
  array.forEach(item => {
    if (typeof item === 'number') {
      total += item;
    } else if (isPlainObject(item) && fieldKey && isNumber$1(item[fieldKey])) {
      total += item[fieldKey];
    }
  });
  return total;
};

/**
 * 生成连续数字数组
 * @param from 连续数字起始值（包含）
 * @param to 连续数字结束值（不包含）
 * ```
 * generateIntArray(0, 5) => [0, 1, 2, 3, 4]
 * ```
 */
function generateIntArray(from, to) {
  const array = [];
  for (let i = from; i < to; i++) {
    array.push(i);
  }
  return array;
}

/**
 * 是否为非空数组
 * ```
 * 结果true满足
 * 1. 必须为数组
 * 2. 数组长度大于0
 * ```
 */
const isNotEmptyArray = value => isArray(value) && value.length > 0;

/**
 * 是否为空数组
 * ```
 * 结果true满足
 * 1. 必须为数组
 * 2. 数组为空
 * ```
 */
const isEmptyArray = value => isArray(value) && value.length === 0;

/**
 * 通过规则字段 来源数组 并入 目标数组
 * @param sourceList 来源数组
 * @param targetList 目标数组
 * @param inRuleFieldName 匹配数组item相同的规则字段，默认值: value
 *
 * ```
 * listInList([{ value: 1, name: '张三', age: 100 }], [{ value: 1, age: 20, sex: 1 }], 'value')
 * =>
 * [{ value: 1, name: '张三', age: 20, sex: 1 }]
 * ```
 */
const listInList = (sourceList, targetList, inRuleFieldName = 'value') => {
  const resultList = targetList.map(item => {
    const target = sourceList.find(sourceItem => !isUndefinedOrNull(item[inRuleFieldName]) && sourceItem[inRuleFieldName] === item[inRuleFieldName]);
    return {
      ...item,
      ...target
    };
  });
  return resultList;
};

/**
 * 数组随机排序
 * @param array
 * @returns
 */
const arrayRandomSort = array => {
  return array.sort(() => {
    return Math.random() > 0.5 ? -1 : 1;
  });
};

/**
 * 转数组
 * @param array
 * @returns
 * ```
 * 例如
 * 1. undefined or null => []
 * 2. [1,2,3] => [1,2,3]
 * 2. 任意其他数据A => [A]
 * ```
 */
const toArray = value => {
  if (isUndefinedOrNull(value)) return [];
  if (isArray(value)) return value;
  return [value];
};

/**
 * 两个数组中元素变换
 * ```
 * 1. sourceIndex、targetIndex超出长度，数组不做任何处理
 * ```
 */
const twoArrayElementPositionChange = (sourceArray, targetArray, sourceIndex, targetIndex) => {
  if (!sourceArray[sourceIndex]) {
    return {
      sourceArray,
      targetArray
    };
  }
  targetArray.splice(targetIndex, 0, sourceArray[sourceIndex]);
  sourceArray.splice(sourceIndex, 1);
  return {
    sourceArray,
    targetArray
  };
};

/**
 * 指定数据转日期格式
 * @param dateInput
 * @returns
 */
const dateNormalize = dateInput => {
  if (!dateInput) {
    throw new Error(`Invalid Date : "${String(dateInput)}"`);
  }
  return dateNormalize$1(dateInput);
};

/**
 * 日期比较：大于等于
 */
const dateTimeGte = (date1, date2) => {
  const date1Fmt = dateNormalize(date1);
  const date2Fmt = dateNormalize(date2);
  return new Date(date1Fmt).getTime() >= new Date(date2Fmt).getTime();
};

/**
 * 日期比较：大于
 */
const dateTimeGt = (date1, date2) => {
  const date1Fmt = dateNormalize(date1);
  const date2Fmt = dateNormalize(date2);
  return new Date(date1Fmt).getTime() > new Date(date2Fmt).getTime();
};

/**
 * 日期比较：等于
 */
const dateTimeEq = (date1, date2) => {
  const date1Fmt = dateNormalize(date1);
  const date2Fmt = dateNormalize(date2);
  return new Date(date1Fmt).getTime() === new Date(date2Fmt).getTime();
};

/**
 * 判断目标日期是否在指定区间内，包含临界值
 * @param targetDate
 * @param minDate
 * @param maxDate
 * ```
 * 例如：targetDate >= minDate && targetDate <= maxDate
 * ```
 */
const dateTimeIn = (targetDate, minDate, maxDate) => {
  return dateTimeGte(targetDate, minDate) && dateTimeGte(maxDate, targetDate);
};

const weekConfig = {
  1: '一',
  2: '二',
  3: '三',
  4: '四',
  5: '五',
  6: '六',
  7: '日'
};

/**
 * 日期解析
 * @param dateInput
 * @returns
 * ```
 * 1. 解析后月份 1～12
 * 2. 解析后星期 1～7
 * ```
 */
const dateDetail = dateInput => {
  const dateInstance = dateNormalize(dateInput);
  const week = dateInstance.getDay();
  const type7Week = week === 0 ? 7 : week;
  return {
    y: dateInstance.getFullYear(),
    m: dateInstance.getMonth() + 1,
    d: dateInstance.getDate(),
    h: dateInstance.getHours(),
    mi: dateInstance.getMinutes(),
    s: dateInstance.getSeconds(),
    ms: dateInstance.getMilliseconds(),
    week: type7Week,
    weekString: weekConfig[type7Week],
    instance: dateInstance
  };
};

/**
 * 在日期【'y' | 'm' | 'd' | 'h' | 'mi' | 's'】中进行加减值处理
 * @param dateInput
 * @param mode 类型 'y' | 'm' | 'd' | 'h' | 'mi' | 's'
 * @param number
 * @returns
 */
const dateNew = (dateInput, mode, number) => {
  return dateNew$1(dateNormalize(dateInput), mode, number);
};

/**
 * 判断日期是否合法
 * @returns boolean
 */
const isDate = dateInput => {
  try {
    return !!dateNormalize(dateInput);
  } catch (_error) {
    return false;
  }
};

const dateFormat = (dateInput, format = 'YYYY-MM-DD') => {
  if (!isDate(dateInput)) {
    return `${dateInput || ''}`;
  }
  return dateFormat$1(dateNormalize(dateInput), format);
};

const flatbizDate = {
  isDate: isDate,
  format: dateFormat,
  gte: dateTimeGte,
  gt: dateTimeGt,
  eq: dateTimeEq,
  detail: dateDetail,
  update: dateNew,
  in: dateTimeIn,
  dateNormalize: dateNormalize
};

/**
 * 查找层层父节点中的目标元素
 * @param originNode  起始节点
 * @param verify 判断是否为目标节点
 */
const findParentsElement = (originNode, verify) => {
  while (originNode != null) {
    if (verify(originNode)) {
      return originNode;
    }
    originNode = originNode.parentNode;
  }
  return null;
};

const overflowScrollReg = /scroll|auto/i;
const defaultRoot = window;
function isElement(node) {
  const ELEMENT_NODE_TYPE = 1;
  return node.tagName !== 'HTML' && node.tagName !== 'BODY' && node.nodeType === ELEMENT_NODE_TYPE;
}

/**
 * 查询指定节点层层父节点中第一个原生滚动节点
 * @param el
 * @param root
 * https://github.com/youzan/vant/issues/3823
 */
function getScrollNode(el, root = defaultRoot) {
  let node = el;
  while (node && node !== root && isElement(node)) {
    const {
      overflowY
    } = window.getComputedStyle(node);
    if (overflowScrollReg.test(overflowY)) {
      return node;
    }
    node = node.parentNode;
  }
  return root;
}

const bodyAppendDivElement = id => {
  const div = document.createElement('div');
  const idNew = id || `id_${Date.now()}`;
  div.setAttribute('id', idNew);
  document.body.append(div);
  return {
    divElement: div,
    elementId: idNew
  };
};
const createDivElement = id => {
  const div = document.createElement('div');
  const idNew = id || `id_${getUuid()}`;
  div.setAttribute('id', idNew);
  return div;
};

// 删除body的子节点
const removeBodyChild = element => {
  try {
    document.body.removeChild(document.querySelector(element));
  } catch (_error) {
    //
  }
};
const dom = {
  bodyAppendDivElement,
  createDivElement,
  removeBodyChild,
  /**
   * 查询指定节点层层父节点中第一个原生滚动节点
   * @param el
   * @param root
   * https://github.com/youzan/vant/issues/3823
   */
  getScrollNode,
  /**
   * 查找层层父节点中的目标元素
   * @param originNode  起始节点
   * @param verify 判断是否为目标节点
   */
  findParentsElement
};

const base64ToFile = (dataurl, filename) => {
  //将base64转换为文件
  const arr = dataurl.split(',');
  const mime = arr[0].match(/:(.*?);/)[1];
  const bstr = atob(arr[1]);
  let n = bstr.length;
  const u8arr = new Uint8Array(n);
  while (n--) {
    u8arr[n] = bstr.charCodeAt(n);
  }
  return new File([u8arr], filename, {
    type: mime
  });
};

const fileToBase64 = file => {
  return new Promise((resolve, reject) => {
    try {
      const reader = new FileReader();
      reader.readAsDataURL(file);
      reader.onload = function () {
        const base64 = reader.result;
        resolve(base64);
      };
      reader.onerror = function (error) {
        reject(error);
      };
    } catch (error) {
      reject(error);
    }
  });
};

/**
 * 图片压缩
 * ```
 * 只支持 jpg、jpeg、png
 * quality：默认值 0.5
 * ratio: 默认值 1
 * threshold: 默认值 1
 * ```
 */
const imageCompressToBase64 = (imageFile, options) => {
  const optionsNew = extend({
    quality: 0.5,
    ratio: 1,
    threshold: 1
  }, options);
  return new Promise((resolve, reject) => {
    const suffix = imageFile.name.substring(imageFile.name.lastIndexOf('.') + 1, imageFile.name.length);
    const imageName = imageFile.name.substring(0, imageFile.name.lastIndexOf('.'));
    const imageSuffix = options?.suffix || suffix;
    const base64Suffix = imageSuffix.toLocaleLowerCase() === 'jpg' ? 'jpeg' : imageSuffix;
    const isLegal = ['png', 'jpg', 'jpeg'].includes(base64Suffix.toLocaleLowerCase());
    void fileToBase64(imageFile).then(imgBase64 => {
      let needCompress = true;
      if (!isLegal) {
        console.info(`${suffix} 文件格式不支持压缩`);
        needCompress = false;
      }
      const fileMb = imageFile.size / 1024 / 1024;
      if (fileMb < optionsNew.threshold) {
        needCompress = false;
      }
      if (!needCompress) {
        resolve({
          base64: imgBase64,
          imageName,
          suffix: base64Suffix
        });
        return;
      }
      const imgage = new Image();
      imgage.src = imgBase64;
      imgage.onload = function () {
        const that = this;
        const width = that.width * optionsNew.ratio;
        const height = that.height * optionsNew.ratio;
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(that, 0, 0, width, height);
        const base64 = canvas.toDataURL(`image/${base64Suffix}`, optionsNew.quality);
        resolve({
          base64,
          imageName,
          suffix: base64Suffix
        });
      };
    }).catch(reject);
  });
};

/**
 * 图片压缩
 * ```
 * 只支持 jpg、jpeg、png
 * quality：默认值 0.5
 * ratio: 默认值 1
 * threshold: 默认值 1
 * ```
 */
const imageCompressToFormData = (imageFile, formDataKey, options) => {
  return new Promise((resolve, reject) => {
    const suffix = imageFile.name.split('.').at(-1) || '';
    const isLegal = ['png', 'jpg', 'jpeg'].includes(suffix.toLocaleLowerCase());
    if (!isLegal) {
      console.info(`${suffix} 文件格式不支持压缩`);
      const formData = new FormData();
      formData.append(formDataKey, imageFile);
      resolve(formData);
      return;
    }
    void imageCompressToBase64(imageFile, options).then(compressInfo => {
      const {
        base64,
        imageName,
        suffix
      } = compressInfo;
      const array = [];
      const bytes = window.atob(base64.split(',')[1]);
      for (let i = 0; i < bytes.length; i++) {
        array.push(bytes.charCodeAt(i));
      }
      const blob = new Blob([new Uint8Array(array)], {
        type: `image/${suffix}`
      });
      const formData = new FormData();
      formData.append(formDataKey, blob, `${imageName}.${suffix}`);
      resolve(formData);
    }).catch(reject);
  });
};

/**
 * 图片压缩
 * ```
 * 只支持 jpg、jpeg、png
 * quality：默认值 0.5
 * ratio: 默认值 1
 * threshold: 默认值 1
 * ```
 */
const imageCompressToFile = (imageFile, options) => {
  const suffix = imageFile.name.split('.').at(-1) || '';
  const isLegal = ['png', 'jpg', 'jpeg'].includes(suffix.toLocaleLowerCase());
  if (!isLegal) {
    console.info(`${suffix} 文件格式不支持压缩`);
    return imageFile;
  }
  return new Promise((resolve, reject) => {
    void imageCompressToBase64(imageFile, options).then(compressInfo => {
      const {
        base64,
        imageName,
        suffix
      } = compressInfo;
      const file = base64ToFile(base64, `${imageName}.${suffix}`);
      resolve(file);
    }).catch(reject);
  });
};

const noop = () => {
  //
};

/**
 * 判断是否为数字（包括字符串数字）
 * ```
 * isNumber(123) // true
 * isNumber('123') // true
 * isNumber('123a') // false
 * isNumber(undefined) // false
 * isNumber(null) // false
 * isNumber('') // false
 * ```
 */
const isNumber = num => {
  if (num === '' || num === undefined || num === null) {
    return false;
  }
  return !isNaN(Number(num));
};

/**
 * 获取枚举类型 value 数组
 * @param enumeration 枚举类型
 * @returns
 * ```
 * 例如：
 * enum AdminTypeEnum {
 *  superAdmin = 1,
 *  generalAdmin = 0,
 * }
 * =>
 * [1,0]
 * ```
 */
const enumValues = enumeration => {
  /**
   * enum AdminTypeEnum {
   *  superAdmin = 1,
   *  generalAdmin = 0,
   * }
   * == Object.keys(AdminTypeEnum) ==>
   * ['0', '1', 'superAdmin', 'generalAdmin']
   */
  const keys = Object.keys(enumeration).filter(k => isNaN(Number(k)));
  return keys.map(k => enumeration[k]);
};

/**
 * 对象转数组（精确）
 * @param mapData map对象
 * @param valueList value数组
 * @param labelName 自定义map key值属性名称，默认：value
 * @param valueName 自定义map value值属性名称，默认：label
 * @returns
 * ```
 * 由于map对象再获取key列表时，都是字符串类型数组，无法精确获取key类型，所以通过valueList来获取key的精确类型
 * const adminTypeMap = {
 *    1:'superAdmin',
 *    2:'generalAdmin',
 * }
 * mapToListExact<MapToListDefaultItem<number>>(adminTypeMap, [1,2])
 * =>
 * 默认值转出格式
 * [{ label: 'superAdmin', value: 1 },{ label: 'generalAdmin', value: 2 }]
 * ```
 */
const mapToListExact = (mapData, valueList, labelName = 'label', valueName = 'value', colorMap) => {
  const tempList = [];
  valueList.map(value => {
    tempList.push({
      [labelName]: mapData[value],
      [valueName]: value,
      color: colorMap?.[value]
    });
  });
  return tempList;
};

/**
 * 对象转数组（非精确转换，精确转换使用mapToListExact）
 * @param map 对象
 * @param labelName 自定义map key值属性名称，默认：value
 * @param valueName 自定义map value值属性名称，默认：label
 * @returns
 * ```
 * 例如
 * const adminType = {
 *    1:'superAdmin',
 *    2:'generalAdmin',
 * }
 * mapToListExact<MapToListDefaultItem<number>>(adminType, [1,2])
 * =>
 * 默认值转出格式
 * [{ label: 'superAdmin', value: '1' },{ label: 'generalAdmin', value: '2' }]
 * ```
 */
const mapToList = (map, labelName = 'label', valueName = 'value') => {
  const list = [];
  Object.keys(map).forEach(key => {
    const obj = {
      [labelName]: map[key],
      [valueName]: key
    };
    list.push(obj);
  });
  return list;
};

/**
 * 从对象数据中，根据规则筛选对象
 * @param data
 * @param keyList
 * @returns
 *
 */
const objectGetObject = (objectData, keyList) => {
  if (!objectData || !keyList || !keyList.length) return {};
  const result = {};
  keyList.forEach(temp => {
    const targetKey = typeof temp === 'string' ? temp : temp.beforeKey;
    const resultKey = typeof temp === 'string' ? temp : temp.afterKey;
    const objectKeys = Object.keys(objectData);
    if (objectKeys.includes(targetKey) && resultKey) {
      result[resultKey] = objectData[targetKey];
    }
  });
  return result;
};

if (!Array.prototype.at) {
  Object.defineProperty(Array.prototype, 'at', {
    enumerable: false,
    configurable: false,
    writable: false,
    value: function at(n) {
      n = Math.trunc(n) || 0;
      if (n < 0) n += this.length;
      if (n < 0 || n >= this.length) return undefined;
      return this[n];
    }
  });
}

if (!Object.is) {
  Object.is = function (x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  };
}

const polyfill = () => {
  console.log('@flatbiz/utils polyfill');
};

/**
 * 金额计算：加
 */
const add = (amt, amt2, option) => {
  return price(amt, extend({
    precision: 10
  }, option)).add(amt2).value;
};

/**
 * 金额计算：减
 */
const subtract = (amt, amt2, option) => {
  return price(amt, extend({
    precision: 10
  }, option)).subtract(amt2).value;
};

/**
 * 金额计算：乘
 */
const multiply = (amt, amt2, option) => {
  return price(amt, extend({
    precision: 10
  }, option)).multiply(amt2).value;
};

/**
 * 金额计算：除
 */
const divide = (amt, amt2, option) => {
  return price(amt, extend({
    precision: 10
  }, option)).divide(amt2).value;
};

/**
 * 金额转换 分 => 万元
 */
const priceFen2wan = (amt, defaultValue = 0) => {
  if (amt === undefined || amt === null || !isNumber(amt)) {
    if (!isNumber(defaultValue)) {
      return defaultValue;
    }
    amt = defaultValue;
  }
  return price(amt).divide(1000000).value;
};

/**
 * 金额转换 分 => 元
 */
const priceFen2yuan = (amt, defaultValue = 0) => {
  if (amt === undefined || amt === null || !isNumber(amt)) {
    if (!isNumber(defaultValue)) {
      return defaultValue;
    }
    amt = defaultValue;
  }
  return price(amt).divide(100).value;
};

/**
 * 格式化金额保留小数点后2位
 */
const priceFormat = (amt, defaultValue = 0, options) => {
  if (amt === undefined || amt === null || !isNumber(amt)) {
    if (!isNumber(defaultValue)) {
      return defaultValue;
    }
    amt = defaultValue;
  }
  const separator = options?.separator === false ? '' : ',';
  const precision = options?.precision ? options.precision : 2;
  return price(amt, {
    precision,
    symbol: '',
    separator
  }).format();
};

/**
 * 金额去除小数点尾号零（会四舍五入处理，默认添加分隔符）
 * ```
 * 例如：
 * 19.00 => 19
 * 19.90 => 19.9
 * 1999.90 => 1,999.9
 * 99.9999 => 100
 * ```
 */
const priceRemoveTailZero = (amt, defaultValue = 0, options) => {
  if (amt === undefined || amt === null || !isNumber(amt)) {
    if (!isNumber(defaultValue)) {
      return defaultValue;
    }
    amt = defaultValue;
  }
  amt = price(amt, {
    precision: 2,
    symbol: '',
    separator: ''
  }).format();
  const priceFt = String(parseFloat(amt)).split('.');
  const separator = options?.separator === false ? '' : ',';
  const firstValue = price(priceFt[0], {
    precision: 0,
    symbol: '',
    separator
  }).format();
  return `${firstValue}${priceFt[1] ? `.${priceFt[1]}` : ''}`;
};

/**
 * 金额分割（会四舍五入处理，默认添加分隔符）
 * ```
 * 例如：
 * 19.09 => ['19', '.09']
 * 99.00 => ['99', '.00']
 * 99.999 => ['100', '.00']
 * ```
 */
const priceSplit = (amt, defaultValue = 0, options) => {
  if (amt === undefined || amt === null || !isNumber(amt)) {
    if (!isNumber(defaultValue)) {
      return [defaultValue, ''];
    }
    amt = defaultValue;
  }
  const precision = options?.precision ? options.precision : 2;
  const priceFt = price(amt, {
    precision,
    symbol: '',
    separator: ''
  }).format().split('.');
  const separator = options?.separator === false ? '' : ',';
  const firstValue = price(priceFt[0], {
    precision: 0,
    symbol: '',
    separator
  }).format();
  return [firstValue, `.${priceFt[1]}`];
};

const priceWan2fen = (amt, defaultValue = 0) => {
  if (amt === undefined || amt === null || !isNumber(amt)) {
    if (!isNumber(defaultValue)) {
      return defaultValue;
    }
    amt = defaultValue;
  }
  return price(amt).multiply(1000000).value;
};

const priceYuan2fen = (amt, defaultValue = 0) => {
  if (amt === undefined || amt === null || !isNumber(amt)) {
    if (!isNumber(defaultValue)) {
      return defaultValue;
    }
    amt = defaultValue;
  }
  return price(amt).multiply(100).value;
};

const flatbizPrice = {
  fen2yuan: priceFen2yuan,
  fen2wan: priceFen2wan,
  yuan2fen: priceYuan2fen,
  wan2fen: priceWan2fen,
  removeTailZero: priceRemoveTailZero,
  format: priceFormat,
  split: priceSplit,
  add: add,
  subtract: subtract,
  multiply: multiply,
  divide: divide
};

function attachPropertiesToComponent(component, properties) {
  const ret = component;
  for (const key in properties) {
    if (Object.prototype.hasOwnProperty.call(properties, key)) {
      ret[key] = properties[key];
    }
  }
  return ret;
}

/**
 * 合并执行 originProps、patchProps中存在的相同命名函数，
 * @param originProps 原对象数据
 * @param patchProps 补丁对象数据
 * @param isMerge 是否浅合并对象，默认值：true
 * ```
 * 1. 主要用于 react 组件函数合并
 * ```
 */
const composeProps = (originProps, patchProps, isMerge) => {
  const isMergeNew = isUndefined(isMerge) ? true : isMerge;
  const composedProps = {
    ...originProps,
    ...(isMergeNew ? patchProps : {})
  };
  Object.keys(patchProps).forEach(key => {
    const func = patchProps[key];
    if (typeof func === 'function') {
      composedProps[key] = (...args) => {
        func(...args);
        return originProps[key]?.(...args);
      };
    }
  });
  return composedProps;
};

/**
 * 延迟
 * @param time 毫米
 * @returns
 */
const sleep = time => new Promise(resolve => setTimeout(resolve, time));

/**
 * 清除空格，可清除前后空格或所有空格
 * @param str
 * @param cancelGlobal 取消所有，只清除前后空格
 */
const trim = (str, cancelGlobal) => {
  if (!str || !isString(str)) return str;
  const patt = cancelGlobal ? /(^\s+)|(\s+$)/g : /\s/g;
  return str.replace(patt, '');
};

/**
 * 获取字符串字节长度
 * @param str
 * @returns
 */
const getStrByteLen = str => {
  const c = str.match(/[^x00-xff]/gi);
  return str.length + (c == null ? 0 : c.length);
};

/**
 * 根据字节长度截取字符串
 * @param str
 * @param bytes
 * @returns
 */
const subStringByBytes = (str, bytes) => {
  let len = 0;
  for (let i = 0; i < str.length; i++) {
    len += str.charCodeAt(i) > 255 ? 2 : 1;
    if (len > bytes) {
      return str.substring(0, i);
    }
  }
  return str;
};

/**
 * 根据[字节长度]来截取字符串
 * @param str 待截取字符数据
 * @param len 截取字节长度
 * @param flow 溢出符，默认...
 */
const cutString = (str, bytes, flow) => {
  str = trim(str || '', true);
  if (!str) return '';
  const cutStr = subStringByBytes(str, bytes);
  if (str.length > cutStr.length) {
    return `${cutStr}${flow || '...'}`;
  }
  return cutStr;
};

/**
 * 字符串格式化
 * @param value 字符串
 * @param format 格式化间隙
 * @returns
 * ```
 * format('18512345678', [3, 4, 4]) => ['185', '1234', '5678']
 * format('18512345678', [3, 2]) => ['185', '12', '345678']
 * format('18512345678', [3, 20]) => ['185', '12345678']
 * format('18512345678', []) => ['18512345678']
 * ```
 */
const stringFormat = (value, format) => {
  try {
    const newValue = trim(value || '');
    if (!isArray(format) || format.length === 0) return [newValue];
    const accumulation = [];
    format.forEach((item, index) => {
      if (index === 0) {
        accumulation.push({
          min: 0,
          max: item
        });
      } else {
        const preValue = accumulation[index - 1].max;
        const currentValue = item + preValue;
        accumulation.push({
          min: preValue,
          max: currentValue
        });
        if (index === format.length - 1 && currentValue < newValue.length) {
          accumulation.push({
            min: currentValue,
            max: newValue.length
          });
        }
      }
    });
    const strArray = [];
    accumulation.forEach(item => {
      const temp = newValue.substring(item.min, item.max);
      if (temp) {
        strArray.push(temp);
      }
    });
    return strArray;
  } catch (error) {
    console.error(error);
  }
  return [];
};

/**
 * 获取 value，如果为undefined、null，则返回 defaultValue
 * ```
 * 1. getValueOrDefault(undefined, '-') => '-'
 * 2. getValueOrDefault(0, '-') => 0
 * ```
 */
const getValueOrDefault = (value, defaultValue) => {
  return isUndefinedOrNull(value) ? defaultValue : value;
};

/**
 * json string 转 json 对象
 * ```
 * 非json字符串会抛异常
 * ```
 */
const jsonStringToJsonObject = jsonString => {
  try {
    window['__json_string_transform'] = null;
    let jsonValue = jsonString;
    let count = 0;
    while (typeof jsonValue != 'object') {
      eval(`window.__json_string_transform=${jsonValue} `);
      jsonValue = window['__json_string_transform'];
      if (count === 10) {
        throw new Error(`数据解析异常，【${jsonString}】`);
      }
      count++;
    }
    return jsonValue;
  } catch (error) {
    throw new Error(error?.message);
  }
};

/**
 * 两个值比较，只用于string、number类型的值比较
 * @param firstValue string、number
 * @param secondValue string、number、Array<string | number>
 * @returns
 * ```
 * 1. 不用区分具体是string还是number
 * 2. secondValue为数组时，firstValue只要和数组中的任意值相等，即返回true
 * ```
 */
const valueIsEqual = (firstValue, secondValue) => {
  const newFirst = !isUndefinedOrNull(firstValue) ? String(firstValue) : null;
  if (isArray(secondValue)) {
    const newSecond = secondValue.map(item => {
      return !isUndefinedOrNull(item) ? String(item) : null;
    });
    return newSecond.findIndex(item => newFirst === item) >= 0;
  } else {
    const newSecond = !isUndefinedOrNull(secondValue) ? String(secondValue) : null;
    return newFirst === newSecond;
  }
};

/**
 * 验证xml格式的正确性
 * ```
 *  result / true 验证通过
 *  result / false 验证不通过，message为失败描述
 * ```
 */
const xmlValidate = xmlContent => {
  // errorCode 0是xml正确，1是xml错误，2是无法验证
  let errorCode = 0;
  let errorMessage;
  // code for IE
  if (window['ActiveXObject']) {
    const xmlDoc = new window['ActiveXObject']('Microsoft.XMLDOM');
    xmlDoc.async = 'false';
    xmlDoc.loadXML(xmlContent);
    if (xmlDoc.parseError.errorCode != 0) {
      errorMessage = `错误code: ${xmlDoc.parseError.errorCode} \n`;
      errorMessage = `${errorMessage} 错误原因: ${xmlDoc.parseError.reason} \n`;
      errorMessage = `${errorMessage} 错误位置: ${xmlDoc.parseError.line}`;
      errorCode = 1;
    } else {
      errorMessage = '格式正确';
    }
  }
  // code for Mozilla, Firefox, Opera, chrome, safari,etc.
  else if (document.implementation['createDocument']) {
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlContent, 'text/xml');
    const error = xmlDoc.getElementsByTagName('parsererror');
    if (error.length > 0) {
      if (xmlDoc.documentElement.nodeName == 'parsererror') {
        errorCode = 1;
        errorMessage = xmlDoc.documentElement.childNodes[0].nodeValue;
      } else {
        errorCode = 1;
        errorMessage = xmlDoc.getElementsByTagName('parsererror')[0].innerHTML;
      }
    } else {
      errorMessage = '格式正确';
    }
  } else {
    errorCode = 2;
    errorMessage = '浏览器不支持验证，无法验证xml正确性';
  }
  return {
    message: errorMessage,
    result: errorCode == 0 ? true : false
  };
};

const storageKey = 'flatbiz';
const localStorageCache = {
  set: (key, value) => {
    localStorage.setItem(`${storageKey}_${key}`, JSON.stringify(value));
  },
  get: key => {
    try {
      const value = localStorage.getItem(`${storageKey}_${key}`);
      if (value) {
        return JSON.parse(value);
      }
    } catch (_error) {
      //
    }
    return {};
  },
  remove: key => {
    localStorage.removeItem(`${storageKey}_${key}`);
  }
};
const sessionStorageCache = {
  set: (key, value) => {
    sessionStorage.setItem(`${storageKey}_${key}`, JSON.stringify(value));
  },
  get: key => {
    try {
      const value = sessionStorage.getItem(`${storageKey}_${key}`);
      if (value) {
        return JSON.parse(value);
      }
    } catch (_error) {
      //
    }
    return {};
  },
  remove: key => {
    sessionStorage.removeItem(`${storageKey}_${key}`);
  }
};

const isMockMeEnv = () => {
  const env = getQueryString('env');
  return env === 'me';
};
const isMockDevEnv = () => {
  const env = getQueryString('env');
  return env === 'dev';
};

/** 是否为mac系统（包含iphone手机） */
const isMacEnv = () => {
  return /macintosh|mac os x/i.test(navigator.userAgent);
};

/** 是否为windows系统 */
const isWindowsEnv = () => {
  return /windows|win32|win64/i.test(navigator.userAgent);
};

/**
 * Mozilla/5.0 (Linux; Android 8.0.0; ALP-AL00 Build/HUAWEIALP-AL00; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/63.0.3239.111 Mobile Safari/537.36/TcFinancial/9.01.06
 * return webview userAgent string.
 */
const userAgent$1 = () => {
  return typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase() : '';
};

/**
 * Check if device is iphone, ipad.
 * @param ua client webview userAgent
 */
const isIphone = () => {
  return /(iphone|ipad)/i.test(userAgent$1());
};
const isMac = () => {
  return /macintosh/i.test(userAgent$1());
};
const isIphoneOrMac = () => {
  return isMac() && isIphone();
};

/**
 * Check if device is android.
 * @param ua client webview userAgent
 */
const isAndroid = () => {
  return /(android)/i.test(userAgent$1());
};

/**
 * 判断当前是否是fabric webview, 拥有插件调用能力
 * Mozilla/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.3 Mobile/15E148 Safari/604.1 Fabric@inhome/1.0.0 Fabric/NoWebview
 * Fabric容器标识 `Fabric@inhome/1.0.0`
 * Fabric容器下通过?ntv_history打开的多一个标识 `Fabric/DisableWebview`注意此标识必须在应用级注入禁用标识, 并且不能随意改变策略, 否则定会出现兼容性问题.
 * @param ua
 */
const isFabricWebview$1 = (ua = userAgent$1()) => {
  const isFabric = new RegExp('fabric@', 'i').test(ua);
  // 目前`Fabric/DisableWebview`强制禁用fabric 能力,即便处于 fabric 容器
  // FIXME:目前 native 处理`Fabric/NoWebview`行为不一致, 所以此处 强制 always 配置 `Fabric/DisableWebview`
  const isDisallowFabric = new RegExp('Fabric/DisableWebview', 'i').test(ua);
  return isFabric && !isDisallowFabric;
};

const getGlobalData = () => {
  return window['GLOBAL'] || {};
};
const getWindow = key => {
  return window[key];
};
const setWindow = data => {
  Object.keys(data).map(key => {
    window[key] = data[key];
  });
};

/**
 * Web浏览器打开新窗口，替代window.open
 * ```
 * 直接使用window.open会被浏览器拦截
 * ```
 */
const openNewWindow = url => {
  const id = getUuid();
  const aElement = document.createElement('a');
  aElement.setAttribute('href', url);
  aElement.setAttribute('target', '_blank');
  aElement.setAttribute('id', id);
  aElement.click();
  setTimeout(() => {
    aElement.parentNode?.removeChild(aElement);
  }, 200);
};

/**
 * 表格合并单元格计算
 *```
 * 操作字段包括合并字段、统计字段
 * 1. 合并字段用于计算单元格合并的格数
 * 2. 统计字段用于统计数值（数字类型），必须依赖于合并字段
 *
 * 计算完成后会在数据中添加部分字段
 * 1. 设置mergeFields mergeKey数组后，会在每一条数据中添加 [mergeKey]RowSpan合并单元格数量字段
 * 2. 设置mergeFields statisticKey后，会在数据中添加 [mergeKey]RowTotal统计字段
 *
 * 写法1：不存在统计字段
 *  tableMergeCellCalculate([], ['key1', 'key2'])
 * 写法2：存在统计字段
 *  tableMergeCellCalculate([], [{ mergeKey: 'key1' }, { mergeKey: 'key2', statisticKey: 'key3' }])
 *
 * demo： https://fex.qa.tcshuke.com/docs/admin/main/table/cell-merge
 *
 *```
 */
const tableMergeCellCalculate = (dataSource, mergeFields, pagination) => {
  if (!isArray(dataSource) || dataSource.length === 0) return [];
  const pageNo = pagination?.pageNo;
  const pageSize = pagination?.pageSize;
  if (pageNo === undefined || pageSize === undefined) {
    dataSource = cloneObject(dataSource);
  } else {
    dataSource = cloneObject(dataSource.slice((pageNo - 1) * pageSize, pageNo * pageSize));
  }
  if (!isArray(mergeFields) || mergeFields.length === 0) return dataSource;
  const mergeFieldsGroup = [];
  mergeFields.forEach((item, index) => {
    const mergeKey = isString(item) ? item : item.mergeKey;
    if (index === 0) {
      mergeFieldsGroup.push([mergeKey]);
    } else {
      mergeFieldsGroup.push([...mergeFieldsGroup[index - 1], mergeKey]);
    }
  });
  function theSameSort(originalData, fieldList) {
    let newOriginalData = [];
    const fieldValueList = originalData.map(originalItem => {
      const originalValue = fieldList.map(temp => originalItem[temp]).join('_');
      return originalValue;
    });
    const newFieldValueList = Array.from(new Set(fieldValueList));
    newFieldValueList.map(filedValue => {
      const tempList = originalData.filter(originalItem => {
        const originalValue = fieldList.map(temp => originalItem[temp]).join('_');
        return filedValue === originalValue;
      });
      newOriginalData = newOriginalData.concat(tempList);
    });
    return newOriginalData;
  }

  // 对数据源进行排序
  let newDataSource = dataSource;
  mergeFieldsGroup.forEach(fields => {
    newDataSource = theSameSort(newDataSource, fields);
  });
  const dataSourceValueGroup = [];
  mergeFieldsGroup.forEach(fieldsGroupItem => {
    const fieldValueList = [];
    newDataSource.forEach(dataSourceItem => {
      let mergeValue = null;
      fieldsGroupItem.forEach(fieldItem => {
        if (!mergeValue) {
          mergeValue = {
            value: dataSourceItem[fieldItem],
            fields: fieldsGroupItem
            // item: dataSourceItem,
          };
        } else {
          mergeValue = {
            value: `${mergeValue.value}_${dataSourceItem[fieldItem]}`,
            fields: fieldsGroupItem
          };
        }
      });
      fieldValueList.push(mergeValue);
    });
    dataSourceValueGroup.push(fieldValueList);
  });
  const newDataSourceValueGroup = [];
  dataSourceValueGroup.forEach(fieldValueList => {
    const newFieldValueList = [];
    fieldValueList.forEach((item, index) => {
      if (index === 0) {
        newFieldValueList.push({
          ...item,
          count: 1
        });
      } else {
        const targetIndex = newFieldValueList.findIndex(newItem => valueIsEqual(newItem.value, item.value));
        if (targetIndex >= 0) {
          newFieldValueList[targetIndex].count = newFieldValueList[targetIndex].count + 1;
        } else {
          newFieldValueList.push({
            ...item,
            count: 1
          });
        }
      }
    });
    newDataSourceValueGroup.push(newFieldValueList);
  });
  const valueUseList = [];
  newDataSource.forEach(dataSourceItem => {
    newDataSourceValueGroup.forEach(item => {
      item.forEach(fieldValueItem => {
        const mergeValueList = [];
        fieldValueItem.fields.forEach(fieldItem => {
          mergeValueList.push(dataSourceItem[fieldItem]);
        });
        const mergeValue = mergeValueList.join('_');
        if (valueIsEqual(mergeValue, fieldValueItem.value)) {
          const lastField = fieldValueItem.fields[fieldValueItem.fields.length - 1];
          if (!valueUseList.find(temp => valueIsEqual(temp, mergeValue))) {
            valueUseList.push(mergeValue);
            dataSourceItem[`${lastField}RowSpan`] = fieldValueItem.count;
          } else {
            dataSourceItem[`${lastField}RowSpan`] = 0;
          }
        }
      });
    });
  });
  // 添加序号
  let _mergeSerialNumber = 1;
  newDataSource.forEach(item => {
    const target = mergeFields[0];
    const mergeKey = typeof target === 'string' ? target : target.mergeKey;
    if (item[`${mergeKey}RowSpan`] > 0) {
      item['_mergeSerialNumber'] = _mergeSerialNumber;
      _mergeSerialNumber += 1;
    }
  });
  const targetList = [];
  mergeFields.forEach(item => {
    if (item.statisticKey) {
      targetList.push({
        mergeKey: item.mergeKey,
        statisticKey: item.statisticKey
      });
    }
  });
  if (targetList.length > 0) {
    targetList.forEach(statisticItem => {
      newDataSource.forEach((item, index) => {
        const rowSpanValue = item[`${statisticItem.mergeKey}RowSpan`];
        if (rowSpanValue && rowSpanValue > 0) {
          item[`${statisticItem.mergeKey}RowTotal`] = newDataSource.slice(index, index + rowSpanValue).reduce((total, node) => {
            const itemTotal = node[statisticItem.statisticKey];
            return isNumber$1(itemTotal) ? flatbizPrice.add(total, itemTotal) : total;
          }, 0);
        }
      });
    });
  }
  return newDataSource;
};

/**
 * 由平铺数组转为树数组
 */
const tiledArrayToTree = (dataList, fieldNames, isRootNode) => {
  if (!dataList.length) return [];
  const dataListClone = cloneObject(dataList);
  const rootNodeList = [];
  const {
    idKeyName,
    pIdKeyName,
    childrenKeyName
  } = fieldNames;
  const dataListMap = arrayToMap(dataListClone, idKeyName);
  dataListClone.forEach(item => {
    const isRootItem = isRootNode(item);
    if (isRootItem) {
      rootNodeList.push(item);
      return;
    }
    const parent = dataListMap[item[pIdKeyName]];
    if (parent) {
      const parentChildren = parent[childrenKeyName];
      if (isArray(parentChildren)) {
        parentChildren.push(item);
      } else {
        parent[childrenKeyName] = [item];
      }
    }
  });
  if (!rootNodeList.length) {
    console.warn('数据中未查询到根节点');
    return [];
  }
  return rootNodeList;
};

/**
 * 树结构数据，复制字段数据为新字段值（配置方式）
 * ```
 * 1. changeFieldNames => { '原字段': '新字段' }，原字段与新字段同时存在
 * 2. childrenName tree结构数据children字段名称，默认值：children
 * ```
 */
const treeFieldNameChange = (treeList, changeFieldNames, childrenName) => {
  const childrenKey = childrenName || 'children';
  const changeFieldList = Object.keys(changeFieldNames);
  function loopHandle(dataItem) {
    if (!dataItem) return;
    changeFieldList.forEach(fieldKey => {
      dataItem[changeFieldNames[fieldKey]] = dataItem[fieldKey];
    });
    if (dataItem[childrenKey] && isArray(dataItem[childrenKey])) {
      dataItem[childrenKey].map(node => {
        loopHandle(node);
      });
    }
  }
  treeList.forEach(dataItem => {
    loopHandle(dataItem);
  });
  return treeList;
};

/**
 * 树结构数据，复制字段数据为新字段值（适配器方式）
 * ```
 * 1. treeItemAdapter 适配器，可在返回值添加新字段数据
 * 2. childrenName tree结构数据children字段名称，默认值：children
 * ```
 */
const treeFieldNameChangeAdapter = (treeList, treeItemAdapter, childrenName) => {
  const childrenKey = childrenName || 'children';
  function loopHandle(dataItem) {
    if (!dataItem) return;
    const adapterResult = treeItemAdapter(dataItem);
    if (adapterResult) {
      Object.keys(adapterResult).forEach(tempKey => {
        dataItem[tempKey] = adapterResult[tempKey];
      });
    }
    if (dataItem[childrenKey] && isArray(dataItem[childrenKey])) {
      dataItem[childrenKey].map(node => {
        loopHandle(node);
      });
    }
  }
  treeList.forEach(dataItem => {
    loopHandle(dataItem);
  });
  return treeList;
};

/**
 * 树结构数据递归遍历适配
 * ```
 * 1. adaptive 适配器，可在返回值添加新字段数据
 * 2. childrenName tree结构数据children字段名称，默认值：children
 * ```
 */
const treeEachAdaptive = (treeDataList, adaptive, childrenName) => {
  return treeFieldNameChangeAdapter(treeDataList, adaptive, childrenName);
};

/**
 * 根据规则过滤tree数据
 * @param dataList tree 数据
 * @param filter 过滤条件 返回false 移除
 * @param options 配置项
 *
 * ```
 *  options配置项目中
 * 1. options.childrenName（tree数据数组节点key字段名称）
 *    默认值：children
 * 2. options.queryParentShowChildrenAll（过滤匹配到父节点是否显示全部子节点，默认值：true）
 *    true：匹配到父节点，则显示全部子节点
 *    false：未匹配到父节点，则移除所有子节点
 * ```
 */
const treeFilter = (dataList, filter, options) => {
  const childrenName = options?.childrenName || 'children';
  const queryParentShowChildrenAll = isUndefined(options?.queryParentShowChildrenAll) ? true : options?.queryParentShowChildrenAll;
  return dataList.reduce((acc, node) => {
    // 检查当前节点是否满足过滤条件
    if (filter(node)) {
      // 如果当前节点有子节点，递归地过滤子节点数组
      if (isNotEmptyArray(node[childrenName])) {
        if (queryParentShowChildrenAll) {
          acc.push(node);
          return acc;
        }
        node[childrenName] = treeFilter(node[childrenName], filter, options);
        if (!isNotEmptyArray(node[childrenName])) {
          node[childrenName] = undefined;
        }
        acc.push(node);
      } else {
        node[childrenName] = undefined;
        acc.push(node);
      }
    } else {
      if (isNotEmptyArray(node[childrenName])) {
        node[childrenName] = treeFilter(node[childrenName], filter, options);
        if (isNotEmptyArray(node[childrenName])) {
          acc.push(node);
        } else {
          node[childrenName] = undefined;
        }
      }
    }
    return acc;
  }, []);
};

/**
 * 根据key值 删除 Tree数据节点以及所有子节点
 * @param key 待删除节点 key
 * @param treeList tree 数据
 * @param options tree 数据字段名称配置
 *
 */
const treeItemDelete = (key, treeList, options) => {
  const childrenName = options.children;
  return treeList.reduce((acc, node) => {
    // 检查当前节点是否满足过滤条件
    if (node[options.key] === key) {
      // 如果当前节点有子节点，递归地过滤子节点数组
      return acc;
    } else {
      if (isNotEmptyArray(node[childrenName])) {
        node[childrenName] = treeItemDelete(key, node[childrenName], options);
        if (!isNotEmptyArray(node[childrenName])) {
          node[childrenName] = undefined;
        }
      }
      acc.push(node);
    }
    return acc;
  }, []);
};

/**
 * 通过过滤器删除树形数据中的节点
 * @param treeList 树形数据
 * @param filter 过滤器 返回true 删除节点
 * @param childrenName
 *
 */
const treeItemDeleteByFilter = (treeList, filter, childrenName) => {
  const childrenKey = childrenName || 'children';
  return treeList.reduce((acc, node) => {
    if (filter(node)) {
      return acc;
    } else {
      if (isNotEmptyArray(node[childrenKey])) {
        node[childrenKey] = treeItemDeleteByFilter(node[childrenKey], filter, childrenKey);
        if (!isNotEmptyArray(node[childrenKey])) {
          node[childrenKey] = undefined;
        }
      }
      acc.push(node);
    }
    return acc;
  }, []);
};

/**
 * 树叶子节点的所有父节点列表
 * @deprecated 已过期，请使用 treeNodeParentsList 方法（入参中列表数据有区别，注意区分）
 * @param value 叶子节点值
 * @param treeTiledList 平铺树结构，可通过treeToArray 将tree数据转为tree平铺数据
 * @param hasSelf 返回是否包含叶子节点，默认值：false
 * @param fieldNames 字段配置，默认值 { value: 'value', parentValue: 'parentValue' }
 * ```
 * fieldNames.parentValue 可传多级，例如: 'parent.id'
 * ```
 */
const treeLeafParentsArray = (value, treeTiledList, hasSelf = false, fieldNames) => {
  const newFieldNames = {
    value: 'value',
    parentValue: 'parentValue',
    ...fieldNames
  };
  const tempList = [];
  function parseChildren(itemValue) {
    const target = treeTiledList.find(temp => temp[newFieldNames.value] === itemValue);
    if (target) {
      tempList.push(target);
      const parentValue = get(target, newFieldNames.parentValue);
      if (!isUndefinedOrNull(parentValue)) {
        parseChildren(parentValue);
      }
    }
  }
  parseChildren(value);
  if (!hasSelf) {
    if (tempList.length > 1) {
      return tempList.splice(1, tempList.length - 1);
    }
    return [];
  }
  return tempList.reverse();
};

/**
 * 树结构数据，由嵌套结构转成平铺【键值对】
 * @param treeDataList tree对象，数据中必须要有唯一值
 * @param fieldNames.value 数组对象中的唯一值
 * @param fieldNames.children 默认值：children
 * @param insertPIdKeyName pId字段名称，设置后树结构转为平铺结构时，会添加父子链路pId
 *
 *```
 * 例如：
 * [{ id: 1, name: '张三' }, { id: 2, name: '李四', chidren: [{ id: 3, name: '李四儿子', }] }]
 * =>
 * { 1: { id: 1, name: '张三' }, 2: { id: 2, name: '李四' }, 3: { id: 3, name: '李四儿子' } }
 * ```
 */
const treeToTiledMap = (treeDataList, fieldNames, insertPIdFieldName) => {
  const childrenKey = fieldNames.children;
  const valueKey = fieldNames.value;
  const tempListMap = {};
  function parseChildren(nodeItem, pUid) {
    const uid = nodeItem[valueKey];
    tempListMap[uid] = nodeItem;
    if (insertPIdFieldName) {
      nodeItem[insertPIdFieldName] = pUid;
    }
    if (nodeItem[childrenKey]) {
      nodeItem[childrenKey].map(childrenIrem => {
        parseChildren(childrenIrem, uid);
      });
    }
  }
  treeDataList.forEach(node => {
    parseChildren(node);
  });
  return tempListMap;
};

/**
 * 指定节点的所有父节点列表
 * @param value 叶子节点值
 * @param treeDataList 树结构数据
 * @param hasSelf 返回是否包含叶子节点，默认值：false
 * @param fieldNames 字段配置，默认值 { value: 'value', children: 'children' }
 * ```
 * 注意：树结构数据中节点value必须唯一不重复
 * ```
 */
const treeNodeParentsList = (value, treeDataList, hasSelf = false, fieldNames) => {
  const valueKey = fieldNames?.value || 'value';
  const childrenKey = fieldNames?.children || 'children';
  const treeListFt = cloneObject(treeDataList);
  const tempList = [];
  const treeTiledMap = treeToTiledMap(treeListFt, {
    value: valueKey,
    children: childrenKey
  }, 'pId');
  let parentNode = treeTiledMap[value];
  while (parentNode) {
    const pId = parentNode.pId;
    parentNode = treeTiledMap[pId];
    if (parentNode) {
      tempList.push(pId);
    }
  }
  if (hasSelf) {
    return [value, ...tempList];
  }
  return tempList;
};

/**
 * 树结构数据，由嵌套结构转成平铺结构，返回值不改变原数据命名
 * @param dataList
 * @param childrenName
 * @param insertPId pId字段设置，设置后树结构转为平铺结构时，会添加父子链路pId
 */
const treeToArray = (treeDataList, childrenName, insertPId) => {
  const tempList = [];
  function parseChildren(nodeItem, pId) {
    tempList.push(nodeItem);
    if (insertPId) {
      nodeItem[insertPId.pIdKeyName] = pId;
    }
    const uid = insertPId?.idName ? nodeItem[insertPId.idName] : undefined;
    if (nodeItem[childrenName]) {
      nodeItem[childrenName].map(node => {
        parseChildren(node, uid);
      });
    }
  }
  treeDataList.forEach(node => {
    parseChildren(node, undefined);
  });
  return tempList;
};

/**
 * 树结构数据，由嵌套结构转成平铺结构，返回数据格式根据fieldNames转换成 { value, label, parentValue }
 * @param dataList
 * @param fieldNames
 * @returns
 */
const treeToTiledArray = (dataList, fieldNames) => {
  const newFieldNames = extend({}, {
    label: 'label',
    value: 'value',
    children: 'children'
  }, fieldNames);
  const labelKey = newFieldNames.label;
  const valueKey = newFieldNames.value;
  const childrenKey = newFieldNames.children;
  const tempList = [];
  function parseChildren(nodeItem, parentValue) {
    tempList.push({
      ...nodeItem,
      label: nodeItem[labelKey],
      value: nodeItem[valueKey],
      parentValue
    });
    if (nodeItem[childrenKey]) {
      nodeItem[childrenKey].map(node => {
        parseChildren(node, nodeItem[valueKey]);
      });
    }
  }
  dataList.forEach(node => {
    parseChildren(node, undefined);
  });
  return tempList;
};

/**
 * 字符串前后斜线，拼接和取消
 * @param str
 * @param slashFix 默认值 true
 * @returns
 * ```
 * 例如：
 * 1. ensureSlash('/abc', true) => /abc/
 * 2. ensureSlash('abc', true) => /abc/
 * 3. ensureSlash('/abc/', false) => abc
 * ```
 *
 */
const ensureSlash = (str, slashFix = true) => {
  str = str.replace(/\/$/, '').replace(/^\//, '');
  return slashFix ? `/${str}/` : str;
};

const userAgent = () => {
  return navigator.userAgent.toLowerCase();
};
const isFabricWebview = () => {
  return new RegExp('fabric@', 'i').test(userAgent());
};

/**
 * 向path中拼接query数据，内部项目使用
 * ```
 * 1.默认query值
 *  1). env 非生产环境有效
 *  2). fabric-callback-key【webview通信key值】
 *  3). accessToken【env=me环境下有效】
 *  4). 业务流程参数 window.bizProcessUrlParam 配置的key值
 * 2.query中undefined会被过滤
 * ```
 */
const toLinkPath = (path, query = {}) => {
  const newQauery = {
    ...query,
    ntv_indicator: '1'
  };
  const env = getQueryString('env');
  if (env && env !== 'prod') {
    newQauery.env = env;
  }
  const media = getQueryString('media');
  if (media) {
    newQauery.media = media;
  }
  if (window['ntv_indicator'] === false || !isFabricWebview()) {
    newQauery.ntv_indicator = undefined;
  }

  // 业务流程参数
  const bizProcessUrlParam = getWindow('bizProcessUrlParam');
  if (isArray(bizProcessUrlParam) && bizProcessUrlParam.length > 0) {
    bizProcessUrlParam.forEach(paramKey => {
      const keyValue = getQueryString(paramKey);
      if (keyValue) {
        newQauery[paramKey] = keyValue;
      }
    });
  }
  const fabricCallbackKey = getQueryString('fabric-callback-key') || '';
  if (fabricCallbackKey) {
    newQauery['fabric-callback-key'] = fabricCallbackKey;
  }
  const accessToken = getQueryString('accessToken') || '';
  if (accessToken && isMockMeEnv()) {
    newQauery.accessToken = accessToken;
  }
  // 将query中的值为 undefined 过滤了
  const filterQuery = {};
  Object.keys(newQauery).filter(key => {
    if (newQauery[key] !== undefined && newQauery[key] !== null) {
      filterQuery[key] = newQauery[key];
    }
  });
  return modifyQueryString(path, filterQuery);
};

const urlJoin = (first, second) => {
  return (first || '').replace(/\/$/, '') + '/' + (second || '').replace(/^\//, '');
};

/**
 * url片段拼接
 * @param first
 * @param second
 * @returns
 */
const urlJoinMulti = (firstUrl, ...fragment) => {
  let str = firstUrl;
  fragment.forEach(item => {
    str = urlJoin(str, item);
  });
  return str;
};

/**
 * 获取指定项目模块地址
 * @param module
 */
const getModuleUrl = (module, query = {}) => {
  const global = getGlobalData();
  const routeBaseName = global.routeBaseName;
  const hostUrl = global.hostUrl;
  const urlBase = urlJoin(hostUrl, routeBaseName);
  return toLinkPath(urlJoin(urlBase, module), query);
};

const isHttpUri = uri => {
  return !uri ? false : uri.startsWith('//') || new RegExp('(https|http)?://').test(uri);
};

/**
 * 比较两个path是否相等
 * @param targetPath 目标path
 * @param comparedPath 被比较path
 * @returns
 */
const pathEqual = (targetPath, comparedPath) => {
  return ensureSlash(targetPath || '', true) === ensureSlash(comparedPath || '', true);
};

/**
 * 比较comparedPath是否包含targetPath
 * @param targetPath 目标path
 * @param comparedPath 被比较path
 * @returns
 */
const pathEqualInclude = (targetPath, comparedPath) => {
  return ensureSlash(comparedPath || '', true).indexOf(ensureSlash(targetPath || '', true)) >= 0;
};

/**
 * 移除字符串前后斜线
 * @param str
 * @param position
 * @returns
 * ```
 * 例如：
 * 1. removeSlash('/abc', 'before') => abc
 * 2. removeSlash('/abc/', 'after') => /abc
 * 3. removeSlash('/abc/', 'before-after') => abc
 * ```
 *
 */
const removeSlash = (str, position) => {
  if (!isString(str) || isUndefinedOrNull(str)) return '';
  if (position === 'before' || position === 'before-after') {
    if (str.startsWith('/')) {
      str = str.substring(1);
    }
  }
  if (position === 'after' || position === 'before-after') {
    if (str.endsWith('/')) {
      str = str.substring(0, str.length - 1);
    }
  }
  return str;
};

/**
 * 根据当前地址协议，获取完整的url地址
 * ```
 * 例如
 * //xxx.com => https://xxx.com
 * ```
 */
const toFullPath = url => {
  if (isHttpUrl(url)) {
    if (url.startsWith('//')) {
      return `${location.protocol}${url}`;
    }
  }
  return url;
};

const toLinkPathWithQuery = (path, query = {}) => {
  return modifyQueryString(path, Object.assign(paramStrToJson(window.location.href), query));
};

const getUrlRoute = url => {
  if (!isHttpUri(url)) return url;
  const pathname = uriParse(url || '').pathname || '';
  const {
    routeBaseName
  } = getGlobalData();
  const route = ensureSlash(pathname, true).replace(ensureSlash(routeBaseName, true), '');
  return `/${ensureSlash(route, false)}`;
};

const is18IdCard = sId => {
  if (!/^\d{17}(\d|X|x)$/.test(sId)) {
    console.log(`[${sId}]:你输入的身份证长度或格式错误`);
    return false;
  }
  //身份证城市
  const aCity = {
    11: '北京',
    12: '天津',
    13: '河北',
    14: '山西',
    15: '内蒙古',
    21: '辽宁',
    22: '吉林',
    23: '黑龙江',
    31: '上海',
    32: '江苏',
    33: '浙江',
    34: '安徽',
    35: '福建',
    36: '江西',
    37: '山东',
    41: '河南',
    42: '湖北',
    43: '湖南',
    44: '广东',
    45: '广西',
    46: '海南',
    50: '重庆',
    51: '四川',
    52: '贵州',
    53: '云南',
    54: '西藏',
    61: '陕西',
    62: '甘肃',
    63: '青海',
    64: '宁夏',
    65: '新疆',
    71: '台湾',
    81: '香港',
    82: '澳门',
    91: '国外'
  };
  if (!aCity[parseInt(sId.substring(0, 2))]) {
    console.log(`[${sId}]:你的身份证地区非法`);
    return false;
  }
  const sBirthday = `${sId.substring(6, 10)}/${sId.substring(10, 12)}/${sId.substring(12, 14)}`;
  const d = new Date(sBirthday);
  if (sBirthday != dateFormat(d, 'YYYY/MM/DD')) {
    console.log(`[${sId}]:身份证上的出生日期非法`);
    return false;
  }

  // 身份证号码校验
  let sum = 0;
  const weights = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2];
  const codes = '10X98765432';
  for (let i = 0; i < sId.length - 1; i++) {
    sum += sId[i] * weights[i];
  }
  const last = codes[sum % 11]; //计算出来的最后一位身份证号码
  if (sId[sId.length - 1] != last) {
    console.log(`[${sId}]:你输入的身份证号非法`);
    return false;
  }
  return true;
};

const flatbizRegExp = {
  /** 汉字格式  */
  chineseCharactersRegExp: /[\u4e00-\u9fa5]/,
  /** 手机号格式  */
  mobileRegExp: /^1[0-9]{10}$/,
  /** 正整数格式 */
  integerRegExp: /^[0-9]*$/,
  /** 金额格式  */
  amountRegExp: /^(([1-9]\d*)|0)(\.\d{1,})?$/,
  /** 密码格式：英文大小写、数字、符号[!@#$%^&*?.]其中两种及以上，长度8-20位 */
  passwordRegExp: /^.*(?=.{8,20})((?=.*\d)(?=.*[A-Z]))|((?=.*\d)(?=.*[a-z]))|((?=.*\d)(?=.*[!@#$%^&*?.]))|((?=.*[A-Z])(?=.*[a-z]))|((?=.*[A-Z])(?=.*[!@#$%^&*?.]))|((?=.*[a-z])(?=.*[!@#$%^&*?.])).*$/,
  /** 8-20位数字和字母的组合 */
  passwordRegExp2: /^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]{8,20}$/
};

export { arrayField2LabelValue, arrayFilter, arrayFilterByLoosely, arrayFind, arrayFindByLoosely, arrayFindIndex, arrayFindIndexByLoosely, arrayMax, arrayMin, arrayPick, arrayPickByLoosely, arrayRandomSort, arrayReorder, arraySetUid, arraySplit, arrayToMap, arrayTotal, arraysReorder, attachPropertiesToComponent, base64ToFile, cloneObject, composeProps, cutString, dom, ensureSlash, enumValues, fileToBase64, flatbizDate, flatbizPrice, flatbizRegExp, generateIntArray, getGlobalData, getModuleUrl, getStrByteLen, getUrlRoute, getUuid, getValueOrDefault, getWindow, imageCompressToBase64, imageCompressToFile, imageCompressToFormData, is18IdCard, isAndroid, isEmptyArray, isFabricWebview$1 as isFabricWebview, isHttpUri, isIphone, isIphoneOrMac, isMac, isMacEnv, isMockDevEnv, isMockMeEnv, isNotEmptyArray, isNumber, isUndefinedOrNull, isWindowsEnv, jsonStringToJsonObject, listInList, localStorageCache, mapToList, mapToListExact, noop, objectGetObject, openNewWindow, pathEqual, pathEqualInclude, polyfill, removeSlash, sessionStorageCache, setWindow, sleep, stringFormat, subStringByBytes, tableMergeCellCalculate, tiledArrayToTree, toArray, toFullPath, toLinkPath, toLinkPathWithQuery, treeEachAdaptive, treeFieldNameChange, treeFieldNameChangeAdapter, treeFilter, treeItemDelete, treeItemDeleteByFilter, treeLeafParentsArray, treeNodeParentsList, treeToArray, treeToTiledArray, treeToTiledMap, trim, twoArrayElementPositionChange, urlJoin, urlJoinMulti, userAgent$1 as userAgent, valueIsEqual, xmlValidate };
//# sourceMappingURL=index.js.map
