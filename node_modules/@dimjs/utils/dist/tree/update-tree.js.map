{"version":3,"file":"update-tree.js","sources":["@dimjs/utils/src/tree/update-tree.ts"],"sourcesContent":["import { CHILDREN_KEY } from './constant.js';\nimport {\n  type ArrayPropertyKey,\n  type TreeNode,\n  type TreeNodeItem,\n} from './types.js';\n\nconst own = {}.hasOwnProperty;\n\n/**\n * @description\n * Create a new tree consisting of copies of all nodes\n * The tree is walked in preorder (NLR), visiting the node itself, then its head, etc.\n *\n * @param tree tree Tree to update\n * @param onUpdate The hook method allow us to `update` every tree item\n * @param childrenKey The key of tree children item\n * @returns Promise\\<TreeNode\\<T,K\\> | null\\>\n *\n * @docsCategory preference/utils/tree\n * @codeFilter tree-update\n */\nexport function updateTree<\n  Node extends TreeNodeItem,\n  Key extends ArrayPropertyKey<Node>,\n>(\n  tree: TreeNode<Node, Key>,\n  onUpdate: (\n    node: TreeNode<Node, Key>,\n    index?: number,\n    parent?: TreeNode<Node, Key>\n  ) => Promise<TreeNode<Node, Key>>,\n  childrenKey?: Key\n): Promise<TreeNode<Node, Key>> {\n  return walkThrough(tree);\n\n  async function walkThrough(\n    node: TreeNode<Node, Key>,\n    index?: number,\n    parent?: TreeNode<Node, Key>\n  ): Promise<TreeNode<Node, Key>> {\n    const children: Node[] = [];\n    let result: Node;\n    let key: string;\n    let childIndex: number;\n    const childKey = childrenKey ?? CHILDREN_KEY;\n\n    const newNode = await onUpdate(node, index, parent);\n    if (node[childKey]) {\n      childIndex = -1;\n\n      // Looks like a parent.\n      while (++childIndex < node[childKey].length) {\n        // Looks like a parent.\n        result = await walkThrough(\n          node[childKey][childIndex],\n          childIndex,\n          newNode\n        );\n\n        if (result) {\n          children.push(result);\n        }\n      }\n    }\n\n    // Create a shallow clone, using the new children.\n    // all the fields will be copied over.\n    const next = {};\n\n    for (key in newNode) {\n      /* istanbul ignore else - Prototype injection. */\n      if (own.call(newNode, key)) {\n        next[key] = key === childKey ? children : newNode[key];\n      }\n    }\n\n    return next as TreeNode<Node, Key>;\n  }\n}\n"],"names":["own","hasOwnProperty","updateTree","tree","onUpdate","childrenKey","walkThrough","node","index","parent","Promise","$return","$error","children","result","key","childIndex","childKey","newNode","next","CHILDREN_KEY","resolve","then","$await_4","$Loop_2_trampoline","$Loop_2","length","$await_5","push","$boundEx","q","pop","$Loop_2_exit","call","this","_exception","bind","$If_1"],"mappings":";6CAOA,IAAMA,EAAM,CAAE,EAACC,eAeR,SAASC,EAIdC,EACAC,EAKAC,GAEA,OAAOC,EAAYH,GAEnB,SAAeG,EACbC,EACAC,EACAC,GAHF,OAAA,IAAAC,SAAA,SAAAC,EAAAC,GAAA,IAKQC,EACFC,EACAC,EACAC,EACEC,EAEAC,EAqBAC,EA3BAN,EAAmB,GAInBI,EAAWZ,IAAW,MAAXA,SAAAA,EAAAA,EAAee,EAEhB,OAAAV,QAAAW,QAAMjB,EAASG,EAAMC,EAAOC,IAA5Ba,KA/CpB,SAAAC,GAAA,IA+CUL,EAAUK,EAChB,GAAIhB,EAAKU,GAAW,CAClBD,GAAc,EAEd,IAAAQ,EAAA,SAAAC,IAAA,KACST,EAAaT,EAAKU,GAAUS,OAAM,CAEhC,OAAAhB,QAAAW,QAAMf,EACbC,EAAKU,GAAUD,GACfA,EACAE,IAHOI,MAIR,SAAAK,GA1DT,IAsDQb,EAASa,EAMT,GAAIb,EAAQ,CACVD,EAASe,KAAKd,EAChB,CA9DR,OAAAW,CAAS,CAAC,MAAAI,GAAW,OAAOjB,EAAAiB,EAAM,CAAC,GAAAjB,EA0D1B,MAAA,MAAA,CAAA,EAAA,CAAA,OA1DRY,EAAiB,SAAUM,GAAsB,MAAOA,EAAG,CAAW,GAAIA,EAAER,KAAoB,YAAYQ,EAAER,KAAIE,EAAAZ,GAAiC,IAAmB,GAAIkB,EAAEC,IAAG,CAAoB,GAAID,EAAEJ,OAA0B,OAAOI,EAAEC,MAAQC,EAAgBC,KAAKC,MAAQJ,OAAwCA,EAACL,CAAW,MAAsCK,EAAIA,EAAEG,KAAKC,KAAiB,CAAC,MAAOC,GAA2B,OAAOvB,EAAMuB,EAAuB,CAAO,CAAE,EAAGC,KAAKF,OAAKT,GAAU,SAAAO,IAAA,OAA/eK,EAAGJ,KAAIC,KAAI,CAgEP,CAGA,SAAAG,IACMlB,EAAO,CAAE,EAEf,IAAKJ,KAAOG,EAAS,CAEnB,GAAIlB,EAAIiC,KAAKf,EAASH,GAAM,CAC1BI,EAAKJ,GAAOA,IAAQE,EAAWJ,EAAWK,EAAQH,EACpD,CACF,CAEA,OAAAJ,EAAOQ,EAA4B,CAAA,OA7EvCkB,EAAGJ,KAAIC,KAAE,CAAC,MAAAL,GAAW,OAAOjB,EAAAiB,EAAM,CAAC,EAAhCO,KAAKF,MAAKtB,EA+C0C,GA+BpD,CACH"}