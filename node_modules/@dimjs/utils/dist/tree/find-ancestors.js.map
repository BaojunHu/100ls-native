{"version":3,"file":"find-ancestors.js","sources":["@dimjs/utils/src/tree/find-ancestors.ts"],"sourcesContent":["import { CHILDREN_KEY } from './constant.js';\nimport {\n  type ArrayPropertyKey,\n  type TreeNode,\n  type TreeNodeId,\n  type TreeNodeItem,\n} from './types.js';\n\n/**\n * @description\n * Determines whether the input is a single node or an array of nodes.\n *\n * @param nodes - The input nodes to check.\n * @returns A boolean indicating whether the input is a single node.\n *\n * @docsCategory preference/utils/tree\n * @docsPage find-ancestors-utils\n */\nconst isSingleNode = <\n  Node extends TreeNodeItem,\n  Key extends ArrayPropertyKey<Node>,\n>(\n  nodes: TreeNode<Node, Key>[] | TreeNode<Node, Key>\n): nodes is TreeNode<Node, Key> => {\n  return !Array.isArray(nodes) && typeof nodes === 'object';\n};\n\n/**\n * @description\n * Options for traversing a tree and finding ancestors.\n *\n * @template Node - The type of the tree node.\n * @template Key - The type of the property key used to access children nodes.\n *\n * @docsCategory preference/utils/tree\n * @docsPage find-ancestors-utils\n */\nexport type FindAncestorsTraverseOptions<\n  Node extends TreeNodeItem,\n  Key extends ArrayPropertyKey<Node>,\n> = {\n  /**\n   * A modifier function that is called for each node in the tree.\n   *\n   * @param node - The current node being traversed.\n   * @param parentId - The ID of the parent node.\n   * @returns The modified node along with its relation to the parent node.\n   */\n  modifier: (\n    node: TreeNode<Node, Key>,\n    parentId?: TreeNodeId\n  ) => FindAncestorsTreeNodeWithRelation<Node, Key>;\n\n  /**\n   * The ID of the parent node to start the traversal from.\n   */\n  parentId?: TreeNodeId;\n\n  /**\n   * The property key used to access children nodes.\n   */\n  childrenKey?: Key;\n};\n\n/**\n * @description\n * Represents a tree node with its ancestors and relations.\n *\n * @template Node - The type of the tree node.\n * @template Key - The type of the array property key of the tree node.\n *\n * @docsCategory preference/utils/tree\n * @docsPage find-ancestors-utils\n */\nexport type FindAncestorsTreeNodeWithRelation<\n  Node extends TreeNodeItem,\n  Key extends ArrayPropertyKey<Node>,\n> = TreeNode<Node, Key> & {\n  parentId?: number;\n  id: TreeNodeId;\n};\n\n/**\n * @description\n * Traverses through a tree structure and finds the first node that satisfies the given predicate.\n *\n * @template Node - The type of the tree node.\n * @template Key - The type of the property key used to access the children of a node.\n * @param nodes - The tree nodes to traverse.\n * @param predicate - The predicate function used to determine if a node satisfies the condition.\n * @param options - The options for traversing the tree.\n * @returns The first node that satisfies the predicate, along with its relation to the parent node, or null if no node is found.\n *\n * @docsCategory preference/utils/tree\n * @docsPage find-ancestors-utils\n */\nconst traverse = <\n  Node extends TreeNodeItem,\n  Key extends ArrayPropertyKey<Node>,\n>(\n  nodes: TreeNode<Node, Key>[] | TreeNode<Node, Key>,\n  predicate: (item: TreeNode<Node, Key>) => boolean,\n  options: FindAncestorsTraverseOptions<Node, Key>\n): FindAncestorsTreeNodeWithRelation<Node, Key> | null => {\n  let result: FindAncestorsTreeNodeWithRelation<Node, Key> | null = null;\n  const modifier = options.modifier;\n  const parentId = options.parentId;\n  const childrenKey = options.childrenKey ?? CHILDREN_KEY;\n\n  // handle array nodes\n  if (Array.isArray(nodes)) {\n    for (let i = 0; i < nodes.length; i++) {\n      result = traverse(nodes[i], predicate, {\n        modifier: modifier,\n        parentId: parentId,\n        childrenKey: childrenKey as Key,\n      });\n      if (result) {\n        break;\n      }\n    }\n  }\n  // handle single node\n  if (isSingleNode(nodes)) {\n    const newNodes = modifier(nodes, parentId);\n    if (predicate(newNodes)) {\n      return newNodes;\n    }\n    if (newNodes[childrenKey] && newNodes[childrenKey].length) {\n      result = traverse(newNodes[childrenKey], predicate, {\n        modifier: modifier,\n        parentId: newNodes.id,\n        childrenKey: childrenKey as Key,\n      });\n    }\n  }\n\n  return result;\n};\n\n/**\n * @description\n * Finds a node in a tree structure that satisfies the given predicate function.\n * Returns the node and its path of ancestors.\n *\n * @template Node - The type of the tree node.\n * @template Key - The type of the property key used to access children nodes.\n * @param nodes - The array of tree nodes to search.\n * @param predicate - The function used to determine if a node satisfies the condition.\n * @param childrenKey - The property key used to access children nodes.\n * @returns An object containing the result node and its path of ancestors.\n *\n * @docsCategory preference/utils/tree\n * @codeFilter tree-find-ancestors\n */\nfunction findNode<\n  Node extends TreeNodeItem,\n  Key extends ArrayPropertyKey<Node>,\n>(\n  nodes: TreeNode<Node, Key>[],\n  predicate: (node: TreeNode<Node, Key>) => boolean,\n  childrenKey?: Key\n) {\n  const path: FindAncestorsTreeNodeWithRelation<Node, Key>[] = [];\n\n  // Assign custom ids to each tree node to identify relationships between\n  // nodes later\n  const modifier = (\n    node,\n    parentId?: TreeNodeId\n  ): FindAncestorsTreeNodeWithRelation<Node, Key> => {\n    if (parentId) {\n      node.parentId = parentId;\n    }\n\n    // Every node during tree traversal is being added to an array\n    // It helps to represent tree structure as a plain list (since each node\n    // has own unique id and pointer to a parent node) and find parent using\n    // iteration instead of recursion\n    path.push(node);\n\n    return node as FindAncestorsTreeNodeWithRelation<Node, Key>;\n  };\n\n  const options = {\n    // Callback that takes every node and its parent (if node is nested)\n    // as arguments. It should return a node.\n    modifier: modifier,\n    childrenKey,\n  };\n\n  const result = traverse(nodes, predicate, options);\n\n  return { result: result, path: path };\n}\n\n/**\n * @description\n * Finds and returns an array of ancestor nodes for a given node in a tree.\n *\n * @template Node - The type of the tree node.\n * @template Key - The type of the key used to identify the nodes.\n * @param {FindAncestorsTreeNodeWithRelation<Node, Key>[]} nodes - The array of tree nodes.\n * @param {FindAncestorsTreeNodeWithRelation<Node, Key> | null} node - The node for which to find the ancestors.\n * @returns {FindAncestorsTreeNodeWithRelation<Node, Key>[]} - The array of ancestor nodes.\n *\n * @docsCategory preference/utils/tree\n * @docsPage find-ancestors-utils\n */\nfunction findParentNodes<\n  Node extends TreeNodeItem,\n  Key extends ArrayPropertyKey<Node>,\n>(\n  nodes: FindAncestorsTreeNodeWithRelation<Node, Key>[],\n  node: FindAncestorsTreeNodeWithRelation<Node, Key> | null\n): FindAncestorsTreeNodeWithRelation<Node, Key>[] {\n  const result: FindAncestorsTreeNodeWithRelation<Node, Key>[] = [];\n\n  if (!nodes.length || !node) {\n    return result;\n  }\n\n  result.push(node);\n\n  while (node.parentId) {\n    let matchedNode;\n\n    for (let i = 0; i < nodes.length; i++) {\n      const item = nodes[i];\n\n      if (item.id !== node.parentId) {\n        continue;\n      }\n\n      node = matchedNode = item;\n      result.push(node);\n    }\n\n    if (!matchedNode) {\n      break;\n    }\n  }\n\n  return result;\n}\n\n/**\n * @description\n * Recursively find tree node and all its ancestors (parents)\n * from a nested data structure (i.e. tree)\n *\n * @param nodes An array of data\n * @param predicate Filter criteria\n * @param childrenKey The key of tree children item\n * @return Matched node and its ancestors\n *\n * @docsCategory preference/utils/tree\n * @codeFilter tree-find-ancestors\n * @docsPage find-ancestors\n */\nexport function findAncestors<\n  Node extends TreeNodeItem,\n  Key extends ArrayPropertyKey<Node>,\n>(\n  nodes: TreeNode<Node, Key>[],\n  predicate: (node: Node) => boolean,\n  childrenKey?: Key\n) {\n  if (!Array.isArray(nodes)) {\n    throw new TypeError('Expected an array but got ' + typeof nodes);\n  }\n\n  if (typeof predicate !== 'function') {\n    throw new TypeError('Expected a function but got ' + typeof predicate);\n  }\n\n  const searchResults = findNode<Node, Key>(nodes, predicate, childrenKey);\n\n  return findParentNodes<Node, Key>(searchResults.path, searchResults.result);\n}\n"],"names":["isSingleNode","nodes","Array","isArray","_typeof","traverse","predicate","options","_options$childrenKey","result","modifier","parentId","childrenKey","CHILDREN_KEY","i","length","newNodes","id","findNode","path","node","push","findParentNodes","matchedNode","item","findAncestors","TypeError","searchResults"],"mappings":";0GAkBA,IAAMA,EAAe,SAAfA,EAIJC,GAEA,OAAQC,MAAMC,QAAQF,IAAUG,EAAOH,KAAU,QACnD,EAuEA,IAAMI,EAAW,SAAXA,EAIJJ,EACAK,EACAC,GACwD,IAAAC,EACxD,IAAIC,EAA8D,KAClE,IAAMC,EAAWH,EAAQG,SACzB,IAAMC,EAAWJ,EAAQI,SACzB,IAAMC,GAAWJ,EAAGD,EAAQK,eAAW,MAAAJ,WAAAA,EAAIK,EAG3C,GAAIX,MAAMC,QAAQF,GAAQ,CACxB,IAAK,IAAIa,EAAI,EAAGA,EAAIb,EAAMc,OAAQD,IAAK,CACrCL,EAASJ,EAASJ,EAAMa,GAAIR,EAAW,CACrCI,SAAUA,EACVC,SAAUA,EACVC,YAAaA,IAEf,GAAIH,EAAQ,CACV,KACF,CACF,CACF,CAEA,GAAIT,EAAaC,GAAQ,CACvB,IAAMe,EAAWN,EAAST,EAAOU,GACjC,GAAIL,EAAUU,GAAW,CACvB,OAAOA,CACT,CACA,GAAIA,EAASJ,IAAgBI,EAASJ,GAAaG,OAAQ,CACzDN,EAASJ,EAASW,EAASJ,GAAcN,EAAW,CAClDI,SAAUA,EACVC,SAAUK,EAASC,GACnBL,YAAaA,GAEjB,CACF,CAEA,OAAOH,CACT,EAiBA,SAASS,EAIPjB,EACAK,EACAM,GAEA,IAAMO,EAAuD,GAI7D,IAAMT,EAAW,SAAXA,EACJU,EACAT,GAEA,GAAIA,EAAU,CACZS,EAAKT,SAAWA,CAClB,CAMAQ,EAAKE,KAAKD,GAEV,OAAOA,CACR,EAED,IAAMb,EAAU,CAGdG,SAAUA,EACVE,YAAAA,GAGF,IAAMH,EAASJ,EAASJ,EAAOK,EAAWC,GAE1C,MAAO,CAAEE,OAAQA,EAAQU,KAAMA,EACjC,CAeA,SAASG,EAIPrB,EACAmB,GAEA,IAAMX,EAAyD,GAE/D,IAAKR,EAAMc,SAAWK,EAAM,CAC1B,OAAOX,CACT,CAEAA,EAAOY,KAAKD,GAEZ,MAAOA,EAAKT,SAAU,CACpB,IAAIY,OAAW,EAEf,IAAK,IAAIT,EAAI,EAAGA,EAAIb,EAAMc,OAAQD,IAAK,CACrC,IAAMU,EAAOvB,EAAMa,GAEnB,GAAIU,EAAKP,KAAOG,EAAKT,SAAU,CAC7B,QACF,CAEAS,EAAOG,EAAcC,EACrBf,EAAOY,KAAKD,EACd,CAEA,IAAKG,EAAa,CAChB,KACF,CACF,CAEA,OAAOd,CACT,CAgBO,SAASgB,EAIdxB,EACAK,EACAM,GAEA,IAAKV,MAAMC,QAAQF,GAAQ,CACzB,MAAM,IAAIyB,UAAU,6BAA4BtB,EAAUH,GAC5D,CAEA,UAAWK,IAAc,WAAY,CACnC,MAAM,IAAIoB,UAAU,+BAA8BtB,EAAUE,GAC9D,CAEA,IAAMqB,EAAgBT,EAAoBjB,EAAOK,EAAWM,GAE5D,OAAOU,EAA2BK,EAAcR,KAAMQ,EAAclB,OACtE"}