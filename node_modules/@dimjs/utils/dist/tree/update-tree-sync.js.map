{"version":3,"file":"update-tree-sync.js","sources":["@dimjs/utils/src/tree/update-tree-sync.ts"],"sourcesContent":["import { CHILDREN_KEY } from './constant.js';\nimport {\n  type ArrayPropertyKey,\n  type TreeNode,\n  type TreeNodeItem,\n} from './types.js';\n\n/**\n * @docsCategory preference/utils/tree\n * @docsPage update-tree-sync\n */\nconst own = {}.hasOwnProperty;\n\n/**\n * Create a new tree consisting of copies of all nodes\n * The tree is walked in preorder (NLR), visiting the node itself, then its head, etc.\n * @param tree tree Tree to update\n * @param onUpdate The hook method allow us to `update` every tree item\n * @param childrenKey The key of tree children item\n * @returns Promise\\<TreeNode\\<T,K\\> | null\\>\n *\n * @docsCategory preference/utils/tree\n * @codeFilter tree-update-sync\n */\nexport function updateTreeSync<\n  Node extends TreeNodeItem,\n  Key extends ArrayPropertyKey<Node>,\n>(\n  tree: TreeNode<Node, Key>,\n  onUpdate: (\n    node: TreeNode<Node, Key>,\n    index?: number,\n    parent?: TreeNode<Node, Key>\n  ) => TreeNode<Node, Key>,\n  childrenKey?: Key\n): TreeNode<Node, Key> {\n  return walkThrough(tree);\n\n  function walkThrough(\n    node: TreeNode<Node, Key>,\n    index?: number,\n    parent?: TreeNode<Node, Key>\n  ): TreeNode<Node, Key> {\n    const children: Node[] = [];\n    let result: Node;\n    let key: string;\n    let childIndex: number;\n    const childKey = childrenKey ?? CHILDREN_KEY;\n\n    const newNode = onUpdate(node, index, parent);\n    if (node[childKey]) {\n      childIndex = -1;\n\n      // Looks like a parent.\n      while (++childIndex < node[childKey].length) {\n        // Looks like a parent.\n        result = walkThrough(node[childKey][childIndex], childIndex, newNode);\n\n        if (result) {\n          children.push(result);\n        }\n      }\n    }\n\n    // Create a shallow clone, using the new children.\n    // all the fields will be copied over.\n    const next = {};\n\n    for (key in newNode) {\n      /* istanbul ignore else - Prototype injection. */\n      if (own.call(newNode, key)) {\n        next[key] = key === childKey ? children : newNode[key];\n      }\n    }\n\n    return next as TreeNode<Node, Key>;\n  }\n}\n"],"names":["own","hasOwnProperty","updateTreeSync","tree","onUpdate","childrenKey","walkThrough","node","index","parent","children","result","key","childIndex","childKey","CHILDREN_KEY","newNode","length","push","next","call"],"mappings":";6CAWA,IAAMA,EAAM,CAAE,EAACC,eAaR,SAASC,EAIdC,EACAC,EAKAC,GAEA,OAAOC,EAAYH,GAEnB,SAASG,EACPC,EACAC,EACAC,GAEA,IAAMC,EAAmB,GACzB,IAAIC,EACJ,IAAIC,EACJ,IAAIC,EACJ,IAAMC,EAAWT,IAAW,MAAXA,SAAAA,EAAAA,EAAeU,EAEhC,IAAMC,EAAUZ,EAASG,EAAMC,EAAOC,GACtC,GAAIF,EAAKO,GAAW,CAClBD,GAAe,EAGf,QAASA,EAAaN,EAAKO,GAAUG,OAAQ,CAE3CN,EAASL,EAAYC,EAAKO,GAAUD,GAAaA,EAAYG,GAE7D,GAAIL,EAAQ,CACVD,EAASQ,KAAKP,EAChB,CACF,CACF,CAIA,IAAMQ,EAAO,CAAE,EAEf,IAAKP,KAAOI,EAAS,CAEnB,GAAIhB,EAAIoB,KAAKJ,EAASJ,GAAM,CAC1BO,EAAKP,GAAOA,IAAQE,EAAWJ,EAAWM,EAAQJ,EACpD,CACF,CAEA,OAAOO,CACT,CACF"}