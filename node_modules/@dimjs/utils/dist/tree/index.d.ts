/**
 * @docsCategory preference/utils/tree
 */
export type Nullable<T> = {
	[P in keyof T]: T[P] | null | undefined;
};
/**
 * @docsCategory preference/utils/tree
 */
export type SetOptional<T, K extends keyof T> = Omit<T, K> & {
	[P in K]?: Nullable<T[P]>;
};
/**
 * 代表一个树节点的ID标识
 * @docsCategory preference/utils/tree
 */
export type TreeNodeId = string | number;
/**
 * @docsCategory preference/utils/tree
 */
export type TreeNodeItem = Record<string, unknown>;
export type ArrayPropertyKey<T> = keyof {
	[K in keyof T as T[K] extends readonly any[] ? K : "children"]: unknown;
};
/**
 * @docsCategory preference/utils/tree
 */
export type TreeNode<Node extends TreeNodeItem, Key extends ArrayPropertyKey<Node>> = Node & {
	[key in Key]: TreeNode<Node, Key>[];
};
/**
 * 一个是否展开属性状态(`expanded`)的转换之后的结构树
 * @docsCategory preference/utils/tree
 */
export type ExpandableTreeNode<Node extends TreeNodeItem, Key extends ArrayPropertyKey<Node>> = TreeNode<Node, Key> & {
	expanded?: boolean;
};
/**
 * 通常在生成树之前, 需要组织的treeNodes数据源, 通常是一个扁平数组
 * @docsCategory preference/utils/tree
 */
export type TreeNodeInput<Node extends TreeNodeItem, Key extends ArrayPropertyKey<Node>> = SetOptional<Node & {
	parent?: null | {
		id: TreeNodeId;
	};
	parentId?: null | TreeNodeId;
} & {
	[key in Key]: SetOptional<TreeNode<Node, Key>, "children">[];
}, "children">;
/**
 * 带带展开属性状态`expandable`新树
 * @docsCategory preference/utils/tree
 */
export type ExpandableTreeNodeResult<Node extends TreeNodeItem, Key extends ArrayPropertyKey<Node>> = TreeNodeInput<Node, Key> & {
	[key in Key]: ExpandableTreeNodeResult<Node, Key>[];
} & {
	expanded?: boolean;
};
/**
 *  代表一颗树转换之后, 生成新树带有`expandable`状态的时候根级的id应该是不存在的.
 * @docsCategory preference/utils/tree
 */
export type RootExpandableTreeNodeResult<Node extends TreeNodeItem, Key extends ArrayPropertyKey<Node>> = Node & {
	[key in Key]: ExpandableTreeNodeResult<Node, Key>[];
};
/**
 * @description
 * Converts an existing tree (as generated by the arrayToTree function) into a flat
 * Map. This is used to persist certain states (e.g. `expanded`) when re-building the
 * tree.
 *
 * @param nodes The flat nodes with optional property `parent`
 * @param currentState
 * @param childrenKey The children property of tree.
 * @returns
 *
 * @docsCategory preference/utils/tree
 * @codeFilter tree-array-to
 * @docsPage array-to-tree
 * @docsWeight 1
 */
export declare function arrayToTree<Node extends {
	id: TreeNodeId;
}, Key extends ArrayPropertyKey<Node>>(nodes: TreeNodeInput<Node, Key>[], currentState?: ExpandableTreeNode<Node, Key>, childrenKey?: Key): RootExpandableTreeNodeResult<Node, Key>;
/**
 * @description
 * Converts an existing tree (as generated by the arrayToTree function) into a flat
 * Map. This is used to persist certain states (e.g. `expanded`) when re-building the
 * tree.
 *
 * @param nodes The flat nodes with optional property `parent`
 * @param childrenKey The children property of tree.
 * @param parentIdFn The function to get the parentId of the node. default is `item.parent?.id??'null'`
 * @returns
 *
 * @docsCategory preference/utils/tree
 * @codeFilter tree-array-to2
 * @docsPage array-to-tree2
 * @docsWeight 1
 */
export declare const arrayToTree2: <Node extends {
	id: TreeNodeId;
}, Key extends ArrayPropertyKey<Node>>(nodes: TreeNodeInput<Node, Key>[], childrenKey?: Key, parentIdFn?: (item: TreeNodeInput<Node, Key>) => TreeNodeId | "null") => RootExpandableTreeNodeResult<Node, Key>;
/**
 * @description
 * Create a new tree consisting of copies of all nodes that pass test.
 * The tree is walked in preorder (NLR), visiting the node itself, then its head, etc.
 *
 * @param tree tree Tree to filter
 * @param test the test function predicate
 * @param options Whether to drop parent nodes if they had children, but all their children were filtered out.
 * @returns Promise\<TreeNode\<T\> | null\>
 *
 * @docsCategory preference/utils/tree
 * @codeFilter tree-filter
 * @docsPage filter-tree
 */
export declare function filterTree<Node extends TreeNodeItem, Key extends ArrayPropertyKey<Node>>(tree: TreeNode<Node, Key>, test: (node: TreeNode<Node, Key>, index?: number, parent?: TreeNode<Node, Key>, level?: number) => Promise<boolean>, options?: {
	cascade: boolean;
	childrenKey?: Key;
}): Promise<TreeNode<Node, Key> | null>;
/**
 * Create a new tree consisting of copies of all nodes that pass test.
 * The tree is walked in preorder (NLR), visiting the node itself, then its head, etc.
 * @param tree tree Tree to filter
 * @param test the test function predicate
 * @param options Whether to drop parent nodes if they had children, but all their children were filtered out.
 * @returns TreeNode<T> | null
 */
export declare function filterTreeSync<Node extends TreeNodeItem, Key extends ArrayPropertyKey<Node>>(tree: TreeNode<Node, Key>, test: (node: TreeNode<Node, Key>, index?: number, parent?: TreeNode<Node, Key>, level?: number) => boolean, options?: {
	cascade: boolean;
	childrenKey?: Key;
}): TreeNode<Node, Key> | null;
/**
 * @description
 * Represents a tree node with its ancestors and relations.
 *
 * @template Node - The type of the tree node.
 * @template Key - The type of the array property key of the tree node.
 *
 * @docsCategory preference/utils/tree
 * @docsPage find-ancestors-utils
 */
export type FindAncestorsTreeNodeWithRelation<Node extends TreeNodeItem, Key extends ArrayPropertyKey<Node>> = TreeNode<Node, Key> & {
	parentId?: number;
	id: TreeNodeId;
};
/**
 * @description
 * Recursively find tree node and all its ancestors (parents)
 * from a nested data structure (i.e. tree)
 *
 * @param nodes An array of data
 * @param predicate Filter criteria
 * @param childrenKey The key of tree children item
 * @return Matched node and its ancestors
 *
 * @docsCategory preference/utils/tree
 * @codeFilter tree-find-ancestors
 * @docsPage find-ancestors
 */
export declare function findAncestors<Node extends TreeNodeItem, Key extends ArrayPropertyKey<Node>>(nodes: TreeNode<Node, Key>[], predicate: (node: Node) => boolean, childrenKey?: Key): FindAncestorsTreeNodeWithRelation<Node, Key>[];
/**
 * @description
 * Converts a tree structure to an array of nodes.
 *
 * @param treeNodes - The array of tree nodes.
 * @param childrenKey - The property key used to access children nodes. If not provided, it defaults to "children".
 *
 * @returns An array of nodes representing the flattened tree structure.
 *
 * @docsCategory preference/utils/tree
 * @codeFilter tree-to-array
 */
export declare function treeToArray<Node extends TreeNodeItem, Key extends ArrayPropertyKey<Node>>(treeNodes: TreeNode<Node, Key>[], childrenKey?: Key): Node[];
/**
 * @description
 * Create a new tree consisting of copies of all nodes
 * The tree is walked in preorder (NLR), visiting the node itself, then its head, etc.
 *
 * @param tree tree Tree to update
 * @param onUpdate The hook method allow us to `update` every tree item
 * @param childrenKey The key of tree children item
 * @returns Promise\<TreeNode\<T,K\> | null\>
 *
 * @docsCategory preference/utils/tree
 * @codeFilter tree-update
 */
export declare function updateTree<Node extends TreeNodeItem, Key extends ArrayPropertyKey<Node>>(tree: TreeNode<Node, Key>, onUpdate: (node: TreeNode<Node, Key>, index?: number, parent?: TreeNode<Node, Key>) => Promise<TreeNode<Node, Key>>, childrenKey?: Key): Promise<TreeNode<Node, Key>>;
/**
 * Create a new tree consisting of copies of all nodes
 * The tree is walked in preorder (NLR), visiting the node itself, then its head, etc.
 * @param tree tree Tree to update
 * @param onUpdate The hook method allow us to `update` every tree item
 * @param childrenKey The key of tree children item
 * @returns Promise\<TreeNode\<T,K\> | null\>
 *
 * @docsCategory preference/utils/tree
 * @codeFilter tree-update-sync
 */
export declare function updateTreeSync<Node extends TreeNodeItem, Key extends ArrayPropertyKey<Node>>(tree: TreeNode<Node, Key>, onUpdate: (node: TreeNode<Node, Key>, index?: number, parent?: TreeNode<Node, Key>) => TreeNode<Node, Key>, childrenKey?: Key): TreeNode<Node, Key>;
/**
 * @docsCategory preference/utils/tree
 * @docsPage walk-through-tree
 * @docsWeight 3
 */
export type OnNodeWalked<Node extends TreeNodeItem, Key extends ArrayPropertyKey<Node>> = (node: TreeNode<Node, Key>, index?: number, parent?: TreeNode<Node, Key>, level?: number) => void;
/**
 * @description
 * Create a new tree consisting of copies of all nodes
 * The tree is walked in preorder (NLR), visiting the node itself, then its head, etc.
 *
 * @param tree The tree to walktrough
 * @param onNodeWalked The hook method to allow we walkThrough the tree node item.
 * @param childrenKey The key of tree children item
 *
 * @docsCategory preference/utils/tree
 * @codeFilter tree-walk-through
 * @docsPage walk-through-tree
 * @docsWeight 1
 */
export declare function walkThroughTree<Node extends TreeNodeItem, Key extends ArrayPropertyKey<Node>>(tree: TreeNode<Node, Key>, onNodeWalked: OnNodeWalked<Node, Key>, childrenKey?: Key): void;

export {};
