{"version":3,"file":"filter-tree-sync.js","sources":["@dimjs/utils/src/tree/filter-tree-sync.ts"],"sourcesContent":["import { CHILDREN_KEY } from './constant.js';\nimport type { ArrayPropertyKey, TreeNode, TreeNodeItem } from './types.js';\n\nconst own = {}.hasOwnProperty;\n\n/**\n * Create a new tree consisting of copies of all nodes that pass test.\n * The tree is walked in preorder (NLR), visiting the node itself, then its head, etc.\n * @param tree tree Tree to filter\n * @param test the test function predicate\n * @param options Whether to drop parent nodes if they had children, but all their children were filtered out.\n * @returns TreeNode<T> | null\n */\nexport function filterTreeSync<\n  Node extends TreeNodeItem,\n  Key extends ArrayPropertyKey<Node>,\n>(\n  tree: TreeNode<Node, Key>,\n  test: (\n    node: TreeNode<Node, Key>,\n    index?: number,\n    parent?: TreeNode<Node, Key>,\n    level?: number\n  ) => boolean,\n  options: { cascade: boolean; childrenKey?: Key } = { cascade: false }\n): TreeNode<Node, Key> | null {\n  return preorder(tree);\n\n  /**\n   * @param {Node} node\n   * @param {number|undefined} [index]\n   * @param {Parent|undefined} [parent]\n   * @param {number|undefined} [level]\n   * @returns {Node|null}\n   */\n  function preorder(\n    node: TreeNode<Node, Key>,\n    index?: number,\n    parent?: TreeNode<Node, Key>,\n    level = 0\n  ): TreeNode<Node, Key> | null {\n    const children: Node[] = [];\n    let result: Node | null;\n    let key: string;\n    let childIndex: number;\n    const childrenKey = options.childrenKey ?? CHILDREN_KEY;\n    const testResult = test(node, index, parent, level);\n    if (!testResult) return null;\n\n    if (node[childrenKey]) {\n      childIndex = -1;\n      level++;\n      // Looks like a parent.\n      while (++childIndex < node[childrenKey].length) {\n        //Looks like a parent.\n        result = preorder(\n          node[childrenKey][childIndex],\n          childIndex,\n          node,\n          level\n        );\n\n        if (result) {\n          children.push(result);\n        }\n      }\n\n      // Looks like a parent.\n      if (options.cascade && node[childrenKey].length && !children.length)\n        return null;\n    }\n\n    // Create a shallow clone, using the new children.\n    // all the fields will be copied over.\n    const next = {};\n\n    for (key in node) {\n      /* istanbul ignore else - Prototype injection. */\n      if (own.call(node, key)) {\n        next[key] = key === childrenKey ? children : node[key];\n      }\n    }\n\n    return next as TreeNode<Node, Key>;\n  }\n}\n"],"names":["own","hasOwnProperty","filterTreeSync","tree","test","options","arguments","length","undefined","cascade","preorder","node","index","parent","_options$childrenKey","level","children","result","key","childIndex","childrenKey","CHILDREN_KEY","testResult","push","next","call"],"mappings":";6CAGA,IAAMA,EAAM,CAAE,EAACC,eAUR,SAASC,EAIdC,EACAC,GAO4B,IAD5BC,EAAgDC,UAAAC,OAAAD,GAAAA,UAAAE,KAAAA,UAAAF,UAAG,GAAA,CAAEG,QAAS,OAE9D,OAAOC,EAASP,GAShB,SAASO,EACPC,EACAC,EACAC,GAE4B,IAAAC,EAAA,IAD5BC,EAAKT,UAAAC,OAAA,GAAAD,UAAA,KAAAE,UAAAF,UAAA,GAAG,EAER,IAAMU,EAAmB,GACzB,IAAIC,EACJ,IAAIC,EACJ,IAAIC,EACJ,IAAMC,GAAWN,EAAGT,EAAQe,eAAW,MAAAN,WAAAA,EAAIO,EAC3C,IAAMC,EAAalB,EAAKO,EAAMC,EAAOC,EAAQE,GAC7C,IAAKO,EAAY,OAAO,KAExB,GAAIX,EAAKS,GAAc,CACrBD,GAAe,EACfJ,IAEA,QAASI,EAAaR,EAAKS,GAAab,OAAQ,CAE9CU,EAASP,EACPC,EAAKS,GAAaD,GAClBA,EACAR,EACAI,GAGF,GAAIE,EAAQ,CACVD,EAASO,KAAKN,EAChB,CACF,CAGA,GAAIZ,EAAQI,SAAWE,EAAKS,GAAab,SAAWS,EAAST,OAC3D,OAAO,IACX,CAIA,IAAMiB,EAAO,CAAE,EAEf,IAAKN,KAAOP,EAAM,CAEhB,GAAIX,EAAIyB,KAAKd,EAAMO,GAAM,CACvBM,EAAKN,GAAOA,IAAQE,EAAcJ,EAAWL,EAAKO,EACpD,CACF,CAEA,OAAOM,CACT,CACF"}