{"version":3,"file":"array-to-tree2.js","sources":["@dimjs/utils/src/tree/array-to-tree2.ts"],"sourcesContent":["import { arrayGroupBy } from '../array/array-group-by.js';\nimport { CHILDREN_KEY } from './constant.js';\nimport {\n  type ArrayPropertyKey,\n  type RootExpandableTreeNodeResult,\n  type TreeNodeId,\n  type TreeNodeInput,\n} from './types.js';\n\n/**\n * @description\n * Converts an existing tree (as generated by the arrayToTree function) into a flat\n * Map. This is used to persist certain states (e.g. `expanded`) when re-building the\n * tree.\n *\n * @param nodes The flat nodes with optional property `parent`\n * @param childrenKey The children property of tree.\n * @param parentIdFn The function to get the parentId of the node. default is `item.parent?.id??'null'`\n * @returns\n *\n * @docsCategory preference/utils/tree\n * @codeFilter tree-array-to2\n * @docsPage array-to-tree2\n * @docsWeight 1\n */\nexport const arrayToTree2 = <\n  Node extends { id: TreeNodeId },\n  Key extends ArrayPropertyKey<Node>,\n>(\n  nodes: TreeNodeInput<Node, Key>[],\n  childrenKey?: Key,\n  parentIdFn?: (item: TreeNodeInput<Node, Key>) => TreeNodeId | 'null'\n): RootExpandableTreeNodeResult<Node, Key> => {\n  const parentIdResolver =\n    parentIdFn ?? ((item) => (item.parent ? item.parent?.id : 'null'));\n\n  const grouped = arrayGroupBy(nodes, parentIdResolver);\n  const parentConsumedMap = new Set<TreeNodeId | null>();\n  const childKey = (childrenKey ?? CHILDREN_KEY) as string;\n\n  function childrenOf(id: TreeNodeId, parentId: TreeNodeId | 'null') {\n    // Clear the consumed map if the parentId is null\n    // If we have multiple entry points, e.g. { null: [ { parentId:null }, { parentId:null } ] }\n    // Each entry point cycle will be calculated separately\n    if (parentId === null || parentId === 'null') {\n      parentConsumedMap.clear();\n    }\n    // Avoid infinite loop\n    if (parentConsumedMap.has(id)) {\n      return [];\n    }\n    // Flag the parentId as consumed\n    parentConsumedMap.add(id);\n    return (grouped[id] || []).map((item) => {\n      return {\n        ...item,\n        id: item.id,\n        [childKey]: childrenOf(item.id, parentIdResolver(item)),\n      };\n    });\n  }\n\n  return {\n    id: 'null',\n    [childKey]: childrenOf('null', 'null'),\n  } as RootExpandableTreeNodeResult<Node, Key>;\n};\n"],"names":["arrayToTree2","nodes","childrenKey","parentIdFn","parentIdResolver","item","_item$parent","parent","id","grouped","arrayGroupBy","parentConsumedMap","Set","childKey","CHILDREN_KEY","childrenOf","parentId","clear","has","add","map","_objectSpread","_defineProperty"],"mappings":";2KAyBO,IAAMA,EAAe,SAAfA,EAIXC,EACAC,EACAC,GAEA,IAAMC,EACJD,IAAU,MAAVA,WAAAA,EAAe,SAACE,GAAI,IAAAC,EAAA,OAAMD,EAAKE,QAAMD,EAAGD,EAAKE,UAAM,MAAAD,SAAXA,OAAAA,EAAAA,EAAaE,GAAK,MAAQ,EAEpE,IAAMC,EAAUC,EAAaT,EAAOG,GACpC,IAAMO,EAAoB,IAAIC,IAC9B,IAAMC,EAAYX,IAAW,MAAXA,SAAAA,EAAAA,EAAeY,EAEjC,SAASC,EAAWP,EAAgBQ,GAIlC,GAAIA,IAAa,MAAQA,IAAa,OAAQ,CAC5CL,EAAkBM,OACpB,CAEA,GAAIN,EAAkBO,IAAIV,GAAK,CAC7B,MAAO,EACT,CAEAG,EAAkBQ,IAAIX,GACtB,OAAQC,EAAQD,IAAO,IAAIY,KAAI,SAACf,GAC9B,OAAAgB,EAAAA,EACKhB,CAAAA,EAAAA,MAAIiB,EAAA,CACPd,GAAIH,EAAKG,IACRK,EAAWE,EAAWV,EAAKG,GAAIJ,EAAiBC,KAErD,GACF,CAEA,OAAAiB,EAAA,CACEd,GAAI,QACHK,EAAWE,EAAW,OAAQ,QAEnC"}