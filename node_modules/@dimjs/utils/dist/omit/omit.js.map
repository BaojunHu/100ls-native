{"version":3,"file":"omit.js","sources":["@dimjs/utils/src/omit/omit.ts"],"sourcesContent":["import { isArray, isObject, isUndefined } from '@dimjs/lang';\nimport { removePropertiesBy } from '../remove-properties-by/remove-properties-by.js';\n\n/**\n * @docsCategory preference/utils/omit\n * @docsPage omit\n */\nexport type RuleFn = (key, value?) => boolean;\n\n/**\n * @description\n * Recursively processes the given value based on the provided rule function.\n * If the value is an object or an array, it traverses through each property or element,\n * applies the rule function, and modifies the value accordingly.\n *\n * @param value - The value to be processed.\n * @param ruleFn - The rule function that determines whether to omit or modify a value.\n * @param path - The current path of the value being processed.\n * @returns The processed value.\n *\n * @docsCategory preference/utils/omit\n * @docsPage omit\n */\nconst processValue = (\n  value,\n  ruleFn: (nodePath: string, value?) => boolean,\n  path = ''\n) => {\n  if (!isObject(value)) {\n    return value;\n  }\n  // handle array\n  if (isArray(value)) {\n    const newValue: any[] = [];\n    for (let i = 0; i < value.length; i++) {\n      const newPath = path ? `${path}[${i}]` : `[${i}]`;\n      if (ruleFn(newPath, value[i])) {\n        continue;\n      }\n      newValue.push(processValue(value[i], ruleFn, newPath));\n    }\n    return newValue;\n  }\n\n  // handle object.\n  for (const key in value) {\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      const newPath = path ? `${path}.${key}` : key;\n      const val = value[key];\n      if (ruleFn(newPath, val)) {\n        value[key] = undefined;\n        continue;\n      }\n      value[key] = processValue(val, ruleFn, newPath);\n    }\n  }\n\n  return value;\n};\n\n/**\n * Returns a function that checks if a given key should be omitted based on the provided rules.\n * @param rules - An array of strings representing the rules to check against.\n * @returns A function that takes a key and returns a boolean indicating whether the key should be omitted.\n *\n * @docsCategory preference/utils/omit\n * @docsPage omit\n */\nconst omitWhenIn = (rules: string[]) => (key: string) => rules.includes(key);\n\n/**\n * @description\n * Creates a new object or array by omitting specified properties or elements from the target object or array.\n *\n * @example\n * ```ts\n *  expect(omit('[0]', ['key1'])).toEqual([]);\n *  expect(omit(['[0]'], [1, 3, 4])).toEqual(expect.arrayContaining([3, 4]));\n *  expect(omit(['key1', 'sex.pwd', 'nest[0]', 'nest[2][0]', 'nest[3].arr.pwd'], {\n *    key: 'key1',\n *    nest: [1, 3, [0, 1, 3, null, undefined], { arr: { pwd: '111', name: 'name' } }],\n *    sex: {\n *      pwd: '',\n *      pwd1: '',\n *    },\n *  })).toMatchObject({\n *    key: 'key1',\n *    nest: [3, [1, 3, null, undefined], { arr: { name: 'name' } }],\n *    sex: {\n *      pwd1: '',\n *    },\n *  });\n * ```\n *\n * @param rules - The properties or elements to omit. Can be a string, an array of strings, or a custom rule function.\n * @param target - The object or array from which to omit properties or elements.\n * @returns A new object or array with the specified properties or elements omitted.\n *\n * @docsCategory preference/utils/omit\n * @codeFilter omit\n */\nexport const omit = <T extends object>(\n  rules: string[] | string | RuleFn,\n  target: T | T[]\n): Record<string, any> => {\n  if (!isObject(target)) {\n    return target;\n  }\n  if (typeof rules === 'string') {\n    rules = [rules];\n  }\n  const ruleFn: any = isArray(rules) ? omitWhenIn(rules as string[]) : rules;\n  const valueClone = Array.isArray(target) ? [...target] : { ...target };\n  const result = processValue(valueClone, ruleFn);\n  return removePropertiesBy(result, (val) => isUndefined(val)) as Record<\n    string,\n    any\n  >;\n};\n"],"names":["processValue","value","ruleFn","path","arguments","length","undefined","_isObject","_isArray","newValue","i","newPath","concat","push","key","Object","prototype","hasOwnProperty","call","val","omitWhenIn","rules","includes","omit","target","valueClone","Array","isArray","_toConsumableArray","_objectSpread","result","removePropertiesBy","_isUndefined"],"mappings":";oXAuBA,IAAMA,EAAe,SAAfA,EACJC,EACAC,GAEG,IADHC,EAAIC,UAAAC,OAAA,GAAAD,UAAA,KAAAE,UAAAF,UAAA,GAAG,GAEP,IAAKG,EAASN,GAAQ,CACpB,OAAOA,CACT,CAEA,GAAIO,EAAQP,GAAQ,CAClB,IAAMQ,EAAkB,GACxB,IAAK,IAAIC,EAAI,EAAGA,EAAIT,EAAMI,OAAQK,IAAK,CACrC,IAAMC,EAAUR,EAAI,GAAAS,OAAMT,EAAIS,KAAAA,OAAIF,EAAC,KAAA,IAAAE,OAAUF,EAAI,KACjD,GAAIR,EAAOS,EAASV,EAAMS,IAAK,CAC7B,QACF,CACAD,EAASI,KAAKb,EAAaC,EAAMS,GAAIR,EAAQS,GAC/C,CACA,OAAOF,CACT,CAGA,IAAK,IAAMK,KAAOb,EAAO,CACvB,GAAIc,OAAOC,UAAUC,eAAeC,KAAKjB,EAAOa,GAAM,CACpD,IAAMH,EAAUR,EAAI,GAAAS,OAAMT,EAAI,KAAAS,OAAIE,GAAQA,EAC1C,IAAMK,EAAMlB,EAAMa,GAClB,GAAIZ,EAAOS,EAASQ,GAAM,CACxBlB,EAAMa,GAAOR,UACb,QACF,CACAL,EAAMa,GAAOd,EAAamB,EAAKjB,EAAQS,EACzC,CACF,CAEA,OAAOV,CACT,EAUA,IAAMmB,EAAa,SAAbA,EAAcC,GAAe,OAAK,SAACP,GAAW,OAAKO,EAAMC,SAASR,EAAI,CAAA,EAiCrE,IAAMS,EAAO,SAAPA,EACXF,EACAG,GAEA,IAAKjB,EAASiB,GAAS,CACrB,OAAOA,CACT,CACA,UAAWH,IAAU,SAAU,CAC7BA,EAAQ,CAACA,EACX,CACA,IAAMnB,EAAcM,EAAQa,GAASD,EAAWC,GAAqBA,EACrE,IAAMI,EAAaC,MAAMC,QAAQH,GAAOI,EAAOJ,GAAMK,EAAA,CAAA,EAASL,GAC9D,IAAMM,EAAS9B,EAAayB,EAAYvB,GACxC,OAAO6B,EAAmBD,GAAQ,SAACX,GAAG,OAAKa,EAAYb,KAIzD"}