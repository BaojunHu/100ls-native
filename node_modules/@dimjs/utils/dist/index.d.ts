/**
 * @description
 * Split array into multi chunks
 *
 * @example
 * ``` ts
 * arrayChunk([1, 2, 3, 4, 5, 6], 2);
 * // => [
 * //     [1, 2],
 * //     [3, 4],
 * //     [5, 6],
 * //   ]
 * ```
 *
 * @param arr the array data
 * @param size chunks size
 *
 * @docsCategory preference/utils/array
 * @codeFilter array-chunk
 */
export declare const arrayChunk: <T>(arr: T[], size: number) => T[][];
export type Recursive<T> = Array<T | Recursive<T>>;
/**
 * @description
 * Creates a new array with all sub-array elements concatenated into it recursively up to the specified depth.
 *
 * @example
 * ``` ts
 * arrayFlattenDeep([1, 2, [3, 4, [5, 6]]]);
 * // => [1, 2, 3, 4, [5, 6]]
 * arrayFlatten([1, 2, [3, 4, [5, 6]]], 2);
 * // => [1, 2, 3, 4, 5, 6]
 * ```
 *
 * @param arr The array to flatten.
 * @param depth default 1
 * @returns A new array with the sub-array elements concatenated into it.
 *
 * @docsCategory preference/utils/array
 * @codeFilter array-flatten
 */
export declare function arrayFlatten<T>(arr: Recursive<T>, depth?: number): Recursive<T>;
/**
 * @description
 * Recursively flattens array.
 *
 * @example
 * ``` ts
 * arrayFlatten([1, 2, [3, 4, [5, 6]]]);
 * // => [ 1, 2, 3, 4, 5, 6 ]
 * ```
 *
 * @param arr The array to flatten.
 * @returns Returns the new flattened array.
 *
 * @docsCategory preference/utils/array
 * @codeFilter array-flatten-deep
 */
export declare function arrayFlattenDeep<T>(arr: Recursive<T>): Array<T>;
/**
 * @description
 * Groups elements of an array based on the result of a callback function.
 *
 * @example
 * ``` ts
 * arrayGroupBy([6.1, 4.2, 6.3], Math.floor);
 * // => { '4': [4.2],'6': [6.1, 6.3] }
 * ```
 *
 * @param array The array to process
 * @param callback Function to determine the group key for each element
 * @returns An object with the grouped elements
 *
 * @docsCategory preference/utils/array
 * @codeFilter array-group-by
 */
export declare function arrayGroupBy<T>(array: T[], callback: (item: T) => string | number): Record<string | number, T[]>;
/**
 * @description
 * Module for returning arrays with a specific length by padding values.
 *
 * @example
 * ``` ts
 * arrayPad([], 2, '*');
 * // => ['*', '*']
 * arrayPad([], 2, '**');
 * // => ['**', '**']
 * ```
 *
 * @param array The array to pad.
 * @param length The padding length.
 * @param chars The string used as padding.
 * @returns Array\<T\>
 *
 * @docsCategory preference/utils/array
 * @codeFilter array-pad
 */
export declare function arrayPad<T = string>(array: Array<T>, length: number, chars: T): T[];
/**
 * @description
 * Returns an array with a specified length by padding, left-padding and right-padding
 *
 * @example
 * ``` ts
 * const one = arrayPadLength([1, 2, 3], -5, 0);
 * one.join('.')
 * // => '0.0.1.2.3'
 * const three = arrayPadLength(two, 7, 9);
 * three.join('.')
 * // => '1.2.3.0.0.9.9'
 * ```
 *
 * @param array array
 * @param length Specifies the number of values to the left or right pad `-5` | `5` sign `-` indicates direction 'left'
 * @param value A placeholder of filling
 *
 * @docsCategory preference/utils/array
 * @codeFilter array-pad-length
 */
export declare const arrayPadLength: <T>(array: T[], length: number, value?: T) => T[];
/**
 * @docsCategory preference/utils/array
 **/
export type ArrayArgs<T> = Array<T extends Array<unknown> ? T[0] : T>;
/**
 * @description
 * Given an array, removes specified elements and returns the modified array
 *
 * @example
 * ``` ts
 * arrayRemove(['red', 'red', 'green', 'red', 'blue'], 'red');
 * // => [ 'green', 'blue']
 * ```
 *
 * @param arr The current array
 * @param values The item that should be removed from all arrays
 * @returns The modified array
 *
 * @docsCategory preference/utils/array
 * @codeFilter array-remove
 */
export declare function arrayRemove<T>(arr: T[], ...values: ArrayArgs<T>): T[];
/**
 * @description
 * Returns an array with only unique values. Objects are compared by reference,
 * unless the `byKey` argument is supplied, in which case matching properties will
 * be used to check duplicates
 *
 * @example
 * ``` ts
 * arrayUnique(['a', 'a', 'b', 'a', 'c', 'a', 'd']);
 * // => ['a', 'b', 'c', 'd']
 * arrayUnique([a, b, a, b, c, a])[1];
 * // => b
 * ```
 *
 * @param arr The array to remove duplicates from.
 * @param byKey Optional key to specify a property to compare for uniqueness.
 * @returns A new array with duplicate elements removed.
 *
 * @docsCategory preference/utils/array
 * @codeFilter array-unique
 */
export declare function arrayUnique<T>(arr: T[], byKey?: keyof T): T[];
/**
 * @description
 * Binds a function to a specific context and partially applies arguments.
 *
 * @example
 * ``` ts
 * const o = { val: 123 };
 * const f = bind(function (this: { val: number }, num: number) {
 *     return this.val * num;
 * }, o);
 * //=>246
 * ```
 *
 * @param fn - The function to bind.
 * @param args - The arguments to partially apply.
 * @returns A new function that, when called, will invoke the original function with the specified context and partially applied arguments.
 *
 * @docsCategory preference/utils/bind
 * @codeFilter bind
 */
export declare const bind: (fn: Function, ...args: any[]) => (...wrapArgs: any[]) => Function;
/**
 * @description
 * We can create an cache seed instance.
 *
 * @example
 * ``` ts
 * const pluginCache = cache('plugin');
 * pluginCache();
 * // => plugin2
 * ```
 *
 * @param prefix the cache group name.
 * @param start The number that seed id start at
 *
 * @docsCategory preference/utils/cache
 * @codeFilter cache
 */
export declare const cache: (prefix?: string, start?: (() => number) | number) => () => string;
/**
 * @docsCategory preference/utils/class-names
 * @docsPage types-class-names
 */
export type ClassValue = string | number | undefined | null | boolean | Record<string, unknown> | ClassArray;
/**
 * @docsCategory preference/utils/class-names
 * @docsPage types-class-names
 */
export type ClassArray = Array<ClassValue>;
/**
 * @docsCategory preference/utils/class-names
 * @docsPage types-class-names
 */
export interface ClassNamesFn {
	(...classes: ClassValue[]): string;
}
/**
 * @description
 * Concatenates and returns a string of CSS class names.
 *
 * @example
 * ``` ts
 * classNames('', 'b', {}, '');
 * // => 'b'
 * classNames(['a', 'b'], ['c', 'd']);
 * // => 'a b c d'
 * ```
 *
 * @param args - The class names to be concatenated.
 * @returns A string of concatenated class names.
 *
 * @docsCategory preference/utils/class-names
 * @codeFilter class-names
 */
export declare const classNames: ClassNamesFn;
/**
 * @description
 * Reads the value of a cookie by its name.
 *
 * @example
 * ``` ts
 * cookieWrite('foo', 'abc');
 * cookieRead('foo');
 * // => abc
 * ```
 *
 * @param name - The name of the cookie.
 * @returns The value of the cookie, or null if the cookie does not exist.
 *
 * @docsCategory preference/utils/cookie
 * @codeFilter cookie
 */
export declare const cookieRead: (name: string) => string | null;
/**
 * @description
 * Removes a cookie by setting its value to an empty string and setting the expiration date to the past.
 *
 * @example
 * ``` ts
 * cookieWrite('foo', 'abc');
 * cookieRemove('foo');
 * cookieRead('foo');
 * // => null
 * ```
 *
 * @param name - The name of the cookie to remove.
 *
 * @docsCategory preference/utils/cookie
 * @codeFilter cookie
 */
export declare const cookieRemove: (name: string) => void;
/**
 * @description
 * Writes a cookie with the specified name, value, and optional parameters.
 *
 * @example
 * ``` ts
 * cookieWrite('foo', 'bar baz%');
 * document.cookie.indexOf('foo=bar%20baz%25') !== -1;
 * // => true
 * ```
 *
 * @param name - The name of the cookie.
 * @param value - The value of the cookie.
 * @param expires - The expiration date of the cookie (in milliseconds since Unix Epoch).
 * @param path - The path on the server where the cookie is valid.
 * @param domain - The domain where the cookie is valid.
 * @param secure - Indicates if the cookie should only be transmitted over secure HTTPS connections.
 *
 * @docsCategory preference/utils/cookie
 * @codeFilter cookie
 */
export declare const cookieWrite: (name: string, value: string, expires?: number, path?: string, domain?: string, secure?: boolean) => void;
/**
 * @description
 * - YYYY:4位年,如1993
 * - YY:2位年,如93; MM:月份; DD:日期; hh:小时; mm:分钟; ss:秒钟
 * - 星期:星期, 返回如 星期二; 周:返回如 周二
 * - week:英文星期全称, 返回如 Saturday
 * - www:三位英文星期, 返回如 Sat
 *
 * @example
 * ``` ts
 * dateFormat(new Date('january 01,2012'));
 * // => 2012-01-01 00:00:00
 * ```
 *
 * @param  date The Date instance(optional)
 * @param  format Date format string. default is `YYYY-MM-DD hh:mm:ss`
 * @return Formatted string.
 *
 * @docsCategory preference/utils/date
 * @codeFilter date-format
 */
export declare const dateFormat: (dateInput: Date | string | number, format?: string) => string;
/**
 * @description
 * Date addition to gives a new value
 *
 * @example
 * ``` ts
 * dateFormat(dateNew('2017-9-25', 'd', 5), 'YYYY-MM-DD');
 * // => 2017-09-30
 * ```
 *
 * @param startDate Original time object.
 * @param newMode A date string expression that represents the time interval to add.
 * @param newNum Date numeric expression that represents the number of time intervals to add or substract, can be positive and negative
 * @return New time object.
 *
 * @docsCategory preference/utils/date
 * @codeFilter date-new
 */
export declare const dateNew: (startDate: Date | string | number, newMode: "y" | "q" | "m" | "w" | "d" | "h" | "mi" | "s", newNum: number) => Date;
/**
 * @description
 * Normalizes a date value to a Date object.
 * - If no date value is provided, the current date and time will be used.
 * - If the date value is a string, it will be converted to a Date object.
 * - If the date value is already a Date object, it will be returned as is.
 * - Throws an error if the resulting date is invalid.
 *
 * @param date - The date value to normalize. Defaults to the current date and time.
 * @returns The normalized Date object.
 * @throws Error if the resulting date is invalid.
 *
 * @docsCategory preference/utils/date
 */
export declare const dateNormalize: (date?: string | number | Date) => Date;
/**
 * @description
 * Calculate how much time is left
 *
 * @note
 * format(hh时mm分ss秒)is required.
 *
 * @example
 * ``` ts
 * timeRemaining(10000, 'YYYY-MM-DD hh:mm:ss秒', '剩余');
 * // => 剩余10秒
 * timeRemaining(3600000, 'YYYY-MM-DD hh:mm:ss秒', '剩余');
 * // => 剩余1:00:00秒
 * ```
 *
 * @param currTime 20000 left the timestrap
 * @param format YYYY年MM月DD日 hh时mm分ss秒
 * @param prefix `剩余`
 * @returns 剩余23时58分
 *
 * @docsCategory preference/utils/date
 * @codeFilter time-remaining
 */
export declare const timeRemaining: (currTime: number, format?: string, prefix?: string) => string;
/**
 * @docsCategory preference/utils/debounce
 * @docsPage types-debounce
 */
export type Procedure = (...args: any[]) => void;
/**
 * @docsCategory preference/utils/debounce
 * @docsPage types-debounce
 */
export interface DebounceOptions {
	isImmediate: boolean;
}
/**
 * @description
 * Debounce create a new function g, which when called will delay the invocation of the original function f until n milliseconds after it was last called.
 *
 * @example
 * ``` ts
 * const debouncedFunction = debounce(func, 100);
 * ```
 *
 * @param func the function which we want to debounce
 * @param waitMilliseconds how many seconds must pass after most recent function call, for the original function to be called
 * @param options
 *
 * @docsCategory preference/utils/debounce
 * @codeFilter debounce
 */
export declare function debounce<F extends Procedure>(func: F, waitMilliseconds?: number, options?: DebounceOptions): (this: any, ...args: any[]) => void;
/**
 * Retrieves the environment-specific configuration value from a given source object.
 *
 * @example
 * ``` ts
 * class EnvConfig {
 *  public rsaPublicKey = {
 *    local: 'local',
 *     prod: 'prod',
 *   };
 * };
 * const envConfig = new EnvConfig();
 * env.getEnvConfig(envConfig, 'rsaPublicKey', 'local')
 * // => local
 * ```
 *
 * @template T - The type of the configuration value to retrieve.
 * @param source - The source object to retrieve the configuration value from.
 * @param path - The path to the configuration value within the source object.
 * @param envName - Optional. The name of the environment. If not provided, the default environment name will be used.
 * @returns The environment-specific configuration value, or `undefined` if not found.
 *
 * @docsCategory preference/utils/env
 * @codeFilter get-env-config
 */
export declare const getEnvConfig: <T = string>(source: any, path: string, envName?: string) => T | undefined;
/**
 * @description
 * Retrieves the environment name from the query string or returns 'prod' as the default value.
 *
 * @param key - The key to retrieve the environment name from the query string. Defaults to 'env'.
 * @returns The environment name.
 *
 * @docsCategory preference/utils/env
 * @codeFilter get-env-name
 */
export declare const getEnvName: (key?: string) => string;
/**
 * @description
 * Merge the contents of two or more objects together into the first object.
 * Avoid use array function, cause of we may allow extend.bind()
 *
 * @note
 * target property `undefined` will be ignored. consider use `null` to override.
 *
 *
 * @example
 * ``` ts
 *  extend({name: 1}, {name: undefined}) ==> {name: 1}
 *  extend(target, [,object1][,objectN])
 *  extend([deep], target, [,object1][,objectN])
 *  1. extend({}, object1, object2);
 *  2. extend(true, {}, object1, object2);
 * ```
 *
 * @param args ([deep], target [,object1][,objectN])
 *
 * @docsCategory preference/utils/extend
 * @codeFilter extend
 */
export declare function extend(this: any, ...args: any[]): any;
/**
 * @description
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * @example
 * ``` ts
 *   let sum = 0;
 *
 *    forEach([1, 2, 3, 4, 5], function (val) {
 *      sum += val;
 *    });
 *
 *    console.log(sum);
 * // => 15
 * ```
 *
 * - If `obj` is an Array callback will be called passing
 * - the value, index, and complete array for each item.
 *
 * - If 'obj' is an Object callback will be called passing
 * - the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @docsCategory preference/utils/for-each
 * @codeFilter for-each
 */
export declare function forEach(obj: any, fn: (value: any, key: any, source: any) => void): void;
/**
 * @docsCategory preference/utils/pick
 * @docsPage types-get
 */
export type IsEmptyObject<T> = T extends null | undefined ? true : T extends {} ? keyof T extends never ? true : false : false;
/**
 * @docsCategory preference/utils/pick
 * @docsPage types-get
 */
export type Path<T extends Record<string, any> | null | undefined> = IsEmptyObject<T> extends true ? string : {
	[Key in keyof T & string]: T[Key] extends object ? `${Key}` | `${Key}.${Path<T[Key]>}` : `${Key}`;
}[keyof T & string];
/**
 * @description
 * Gets the value at path of object. TODO: typings.
 *
 * @example
 * ``` ts
 * get({ a: { b: false } }, 'a.b');
 * // => false
 * get(undefined, 'a.b', '1');
 * // => 1
 * ```
 *
 * @param source The object to query.
 * @param path The path of the property to get.
 * @param defaultValue The value returned for undefined resolved values.
 *
 * @docsCategory preference/utils/get
 * @codeFilter get
 */
export declare const get: <T extends Record<string, any> | null | undefined, K extends Path<T>>(source: T, path: K, defaultValue?: any) => any;
type IsEmptyObject$1<T> = T extends null | undefined ? true : T extends {} ? keyof T extends never ? true : false : false;
type Path$1<T extends Record<string, any> | null | undefined> = IsEmptyObject$1<T> extends true ? string : {
	[Key in keyof T & string]: T[Key] extends object ? `${Key}` | `${Key}.${Path$1<T[Key]>}` : `${Key}`;
}[keyof T & string];
/**
 * @description
 * Get the context of target `path` object
 *
 * @param source The object to query.
 * @param path The path of the property to get.
 *
 * @docsCategory preference/utils/get-ctx
 * @codeFilter get-ctx
 */
export declare const getCtx: <T extends Record<string, any> | null | undefined, K extends Path$1<T>>(source: T, path: K, defaultValue?: any) => unknown;
/**
 * @docsCategory preference/utils/json
 * @docsPage types-deep-parse
 */
export type PlainObject = Record<string, any>;
/**
 * @description
 * Recursively parses a JSON string or object, converting stringified values to their corresponding types.
 * If the input is an object, it will traverse the object and parse each value recursively.
 *
 * @param jsonStr - The JSON string or object to parse.
 * @param result - The result object to store the parsed values. Defaults to an empty object.
 * @returns The parsed JSON object with stringified values converted to their corresponding types.
 *
 * @docsCategory preference/utils/json
 * @codeFilter deep-parse
 * @docsPage deep-parse
 */
export declare const deepParse: (jsonStr: string | PlainObject, result?: PlainObject) => unknown;
/**
 * @description
 * Parses a JSON string or object and returns the parsed result.
 *
 * @param json - The JSON string or object to parse.
 * @returns The parsed result.
 *
 * @docsCategory preference/utils/json
 * @codeFilter parse
 */
export declare const parse: <T = unknown>(json: any) => T;
/**
 * @docsCategory preference/utils/json
 * @codeFilter sort
 * @docsPage sort
 */
export type SortJsonProps = {
	level?: number;
	depth?: number;
	reverse?: boolean;
	ignoreCase?: boolean;
};
/**
 * @description
 * Sorts the keys on objects
 *
 * @example
 * ``` ts
 * sort({ C: 3, a: 1, B: 2 }, { ignoreCase: true });
 * //=> { a: 1, B: 2, C: 3 }
 * ```
 *
 * @param {*} old                           - An object to sort the keys of, if not object just
 * @param {Object} [sortOptions = {}]       - optional parameters
 * @param [options.reverse = false]         - When sorting keys, converts all keys to lowercase so
 * @param [options.ignoreCase = false]      - When sorting keys, converts all keys to
 * @param [options.depth = Infinity]        - Depth's level sorting keys on a
 * @returns {*}                             - Object with sorted keys, if old wasn't an object
 *                                            returns whatever was passed
 * @docsCategory preference/utils/json
 * @codeFilter sort
 * @docsPage sort
 */
export declare const sort: (old: Record<string, any>, options?: SortJsonProps) => Record<string, any>;
/**
 * @description
 * Converts an object to a JSON string.
 *
 * @example
 * ``` ts
 * JSON.stringify(610523198909255112)
 * // => "610523198909255200"
 * ```
 *
 * @param obj - The object to be converted.
 * @param pretty - The number of spaces to use for indentation (optional).
 * @returns The JSON string representation of the object.
 *
 *
 * @docsCategory preference/utils/json
 * @codeFilter stringify
 */
export declare const stringify: (obj: any, pretty?: number) => string;
/**
 * @description
 * A recursive implementation of the Partial\<T\> type.
 * Source: https://stackoverflow.com/a/49936686/772859
 *
 * @docsCategory preference/utils/merge-options
 * @docsPage types-types-merge
 */
export type DeepPartial<T> = {
	[P in keyof T]?: null | (T[P] extends Array<infer U> ? Array<DeepPartial<U>> : T[P] extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : DeepPartial<T[P]>);
};
/**
 * @description
 * Performs a deep merge of two Plugin options merge objects. Unlike `Object.assign()` the `target` object is
 * not mutated, instead the function returns a new object which is the result of deeply merging the
 * values of `source` into `target`.
 *
 * Arrays do not get merged, they are treated as a single value that will be replaced. So if merging the
 * `plugins` array, you must explicitly concatenate the array.
 *
 * @example
 * ``` ts
 * const result = mergeOptions(defaultConfig, {
 *   assetOptions: {
 *     uploadMaxFileSize: 5000,
 *   },
 *   plugins: [
 *     ...defaultConfig.plugins,
 *     MyPlugin,
 *   ]
 * };
 * ```
 *
 * @param {T} target - The target object to merge into.
 * @param {DeepPartial<T>} source - The source object to merge from.
 * @param {boolean} [mergeUndefined=false] - Whether to merge undefined values.
 * @param {number} [depth=0] - The current depth of the merge operation.
 * @returns {T} - The merged object.
 *
 * @docsCategory preference/utils/merge-options
 * @codeFilter merge-options
 * @docsPage merge-options
 */
export declare function mergeOptions<T>(target: T, source: DeepPartial<T>, mergeUndefined?: boolean, depth?: number): T;
/**
 * @docsCategory preference/utils/number
 * @docsPage types-number
 */
export type NumType = number | string;
/**
 * @description
 * Returns the length of the decimal part of a number.
 * @param num - The number to calculate the decimal length of.
 * @returns The length of the decimal part of the number.
 *
 * @docsCategory preference/utils/number
 * @codeFilter digit-length
 */
export declare const digitLength: (num: NumType) => number;
/**
 * @description
 * Divides two numbers and returns the result.
 * If additional numbers are provided, it performs a series of divisions.
 *
 *
 * @param num1 The first number to divide.
 * @param num2 The second number to divide.
 * @param others Additional numbers to divide.
 * @returns The result of the division.
 *
 * @docsCategory preference/utils/number
 * @codeFilter divide
 */
export declare const divide: (num1: NumType, num2: NumType, ...others: NumType[]) => number;
/**
 * @description
 * Checks if the given number is within the safe integer boundary.
 * If the number is beyond the boundary, a warning message is logged.
 *
 * @param num - The number to be checked.
 *
 * @docsCategory preference/utils/number
 * @docsPage types-number
 */
export declare const checkBoundary: (num: number) => void;
/**
 * @description
 * Converts a floating-point number to a fixed-point number.
 * If the number is in scientific notation, it will be converted to a fixed-point number.
 *
 * @param num - The number to convert.
 * @returns The converted fixed-point number.
 *
 * @docsCategory preference/utils/number
 * @codeFilter float2-fixed
 */
export declare const float2Fixed: (num: NumType) => number;
/**
 * @description
 * Subtracts two numbers and returns the result.
 * If additional numbers are provided, it subtracts them sequentially.
 *
 * @param num1 The first number to subtract.
 * @param num2 The second number to subtract.
 * @param others Additional numbers to subtract.
 * @returns The result of the subtraction.
 *
 * @docsCategory preference/utils/number
 * @codeFilter minus
 */
export declare const minus: (num1: NumType, num2: NumType, ...others: NumType[]) => number;
/**
 * @description
 * Adds two or more numbers together.
 *
 * @param num1 The first number to add.
 * @param num2 The second number to add.
 * @param others Additional numbers to add.
 * @returns The sum of all the numbers.
 *
 * @docsCategory preference/utils/number
 * @codeFilter plus
 */
export declare const plus: (num1: NumType, num2: NumType, ...others: NumType[]) => number;
/**
 * @description
 * Rounds a number to a specified decimal place.
 *
 * @param num - The number to round.
 * @param ratio - The number of decimal places to round to.
 * @returns The rounded number.
 *
 * @docsCategory preference/utils/number
 * @codeFilter round
 */
export declare const round: (num: NumType, ratio: number) => number;
/**
 * @description
 * Fix wrong number input.
 * strip(0.09999999999999998)=0.1
 *
 * @docsCategory preference/utils/number
 * @codeFilter strip
 */
export declare const strip: (num: NumType, precision?: number) => number;
/**
 * @description
 * Multiplies two numbers together.
 *
 * @param num1 The first number to multiply.
 * @param num2 The second number to multiply.
 * @param others Additional numbers to multiply.
 * @returns The result of multiplying all the numbers together.
 *
 * @docsCategory preference/utils/number
 * @codeFilter times
 */
export declare const times: (num1: NumType, num2: NumType, ...others: NumType[]) => number;
/**
 * @docsCategory preference/utils/omit
 * @docsPage omit
 */
export type RuleFn = (key: any, value?: any) => boolean;
/**
 * @description
 * Creates a new object or array by omitting specified properties or elements from the target object or array.
 *
 * @example
 * ```ts
 *  expect(omit('[0]', ['key1'])).toEqual([]);
 *  expect(omit(['[0]'], [1, 3, 4])).toEqual(expect.arrayContaining([3, 4]));
 *  expect(omit(['key1', 'sex.pwd', 'nest[0]', 'nest[2][0]', 'nest[3].arr.pwd'], {
 *    key: 'key1',
 *    nest: [1, 3, [0, 1, 3, null, undefined], { arr: { pwd: '111', name: 'name' } }],
 *    sex: {
 *      pwd: '',
 *      pwd1: '',
 *    },
 *  })).toMatchObject({
 *    key: 'key1',
 *    nest: [3, [1, 3, null, undefined], { arr: { name: 'name' } }],
 *    sex: {
 *      pwd1: '',
 *    },
 *  });
 * ```
 *
 * @param rules - The properties or elements to omit. Can be a string, an array of strings, or a custom rule function.
 * @param target - The object or array from which to omit properties or elements.
 * @returns A new object or array with the specified properties or elements omitted.
 *
 * @docsCategory preference/utils/omit
 * @codeFilter omit
 */
export declare const omit: <T extends object>(rules: string[] | string | RuleFn, target: T | T[]) => Record<string, any>;
/**
 * @description
 * Creates a new object with the specified properties from the given object.
 *
 * @param obj - The object from which to pick properties.
 * @param keys - The properties to pick. Can be a string or an array of strings.
 * @returns A new object with the picked properties.
 *
 * @docsCategory preference/utils/pick
 * @codeFilter pick
 */
export declare const pick: <T extends object, TKeys extends keyof T>(obj: T, keys: TKeys[] | TKeys) => Pick<T, TKeys>;
declare namespace currency {
	type Any = number | string | currency;
	type Format = (currency?: currency, opts?: Options) => string;
	interface Constructor {
		(value: currency.Any, opts?: currency.Options): currency;
		new (value: currency.Any, opts?: currency.Options): currency;
	}
	interface Options {
		symbol?: string;
		separator?: string;
		decimal?: string;
		errorOnInvalid?: boolean;
		precision?: number;
		increment?: number;
		useVedic?: boolean;
		pattern?: string;
		negativePattern?: string;
		format?: currency.Format;
		fromCents?: boolean;
	}
}
export interface currency {
	add(number: currency.Any): currency;
	subtract(number: currency.Any): currency;
	multiply(number: currency.Any): currency;
	divide(number: currency.Any): currency;
	distribute(count: number): Array<currency>;
	dollars(): number;
	cents(): number;
	format(opts?: currency.Options | currency.Format): string;
	toString(): string;
	toJSON(): number;
	readonly intValue: number;
	readonly value: number;
}
declare const currency: currency.Constructor;
/**
 * @docsCategory preference/utils/price
 * @docsPage types-price
 */
export type ValueType = number | string | currency;
/**
 * @docsCategory preference/utils/price
 * @docsPage types-price
 */
export type QuickPriceCalcApi = {
	toString(): string;
	format(): string;
	add(target: ValueType): currency;
	subtract(target: ValueType): currency;
	multiply(target: ValueType): currency;
	divide(target: ValueType): currency;
	equals(target: ValueType): boolean;
	lessThan(target: ValueType): boolean;
	lessEqlThan(target: ValueType): boolean;
	greaterThan(target: ValueType): boolean;
	greaterEqlThan(target: ValueType): boolean;
};
/**
 * @docsCategory preference/utils/price
 * @docsPage types-price
 */
export type PriceOption = {
	symbol?: string;
	separator?: string;
	decimal?: string;
	formatWithSymbol?: boolean;
	errorOnInvalid?: boolean;
	precision?: number;
	increment?: number;
	useVedic?: boolean;
};
/**
 * @description
 * Creates a QuickPriceCalcApi object for performing calculations and formatting on a given value.
 *
 * @example
 * ``` ts
 * price('3.8923').toString();
 * // => '3.89'
 * price('1237.72', { symbol: '€', separator: ',' }).format()
 * // => '€1,237.72'
 * ```
 *
 * @param value - The value to be used for calculations.
 * @param option - Optional configuration options for formatting.
 * @returns A QuickPriceCalcApi object with various methods for performing calculations and formatting.
 *
 * @docsCategory preference/utils/price
 * @codeFilter price
 */
export declare const price: (value: ValueType, option?: PriceOption) => QuickPriceCalcApi;
/**
 * @description
 * Removes properties from an object or an array of objects based on a given condition.
 *
 * @param obj - The object or array of objects from which properties will be removed.
 * @param removeFn - A function that determines whether a property should be removed or not.
 *                   It takes the property value and key as arguments and should return a boolean value.
 * @returns The object or array of objects with the specified properties removed.
 *
 *
 * @docsCategory preference/utils/remove-properties-by
 * @codeFilter remove-properties-by
 */
export declare function removePropertiesBy(obj: any, removeFn: (value: any, key: string) => boolean): unknown;
/**
 * @description
 * Determines if two versions are equal.
 *
 * @param verA - The first version.
 * @param verB - The second version.
 * @returns True if the versions are equal, false otherwise.
 *
 * @docsCategory preference/utils/semver
 * @docsPage semver-eq
 * @codeFilter eq
 */
export declare const eq: (verA: string, verB: string) => boolean;
/**
 * @description
 * Determines if version `verA` is greater than version `verB`.
 *
 * @param verA - The first version to compare.
 * @param verB - The second version to compare.
 * @returns `true` if `verA` is greater than `verB`, `false` otherwise.
 *
 * @docsCategory preference/utils/semver
 * @docsPage semver-gt
 * @codeFilter gt
 */
export declare const gt: (verA: string, verB: string) => boolean;
/**
 * @description
 * Determines if verA is greater than or equal to verB.
 *
 * @param verA - The first version to compare.
 * @param verB - The second version to compare.
 * @returns True if verA is greater than or equal to verB, false otherwise.
 *
 * @docsCategory preference/utils/semver
 * @docsPage semver-gte
 * @codeFilter gte
 */
export declare const gte: (verA: string, verB: string) => boolean;
/**
 * @description
 * Determines if version `verA` is less than version `verB`.
 *
 * @param verA - The first version to compare.
 * @param verB - The second version to compare.
 * @returns `true` if `verA` is less than `verB`, `false` otherwise.
 *
 * @docsCategory preference/utils/semver
 * @docsPage semver-lt
 * @codeFilter lt
 */
export declare const lt: (verA: string, verB: string) => boolean;
/**
 * @description
 * Determines if version A is less than or equal to version B.
 *
 * @param verA - The first version to compare.
 * @param verB - The second version to compare.
 * @returns True if version A is less than or equal to version B, false otherwise.
 *
 * @docsCategory preference/utils/semver
 * @docsPage semver-lte
 * @codeFilter lte
 */
export declare const lte: (verA: string, verB: string) => boolean;
/**
 * @description
 *
 * Returns the formatted version string displayed on the client, with the version number major.min.patch always remaining three digits
 *
 * @param ver version string
 *
 * @docsCategory preference/utils/semver
 * @docsPage semver-normalize
 * @codeFilter normalize
 */
export declare const normalize: (ver: string) => string;
/**
 * @description
 * Validates a version string.
 *
 * @param ver - The version string to validate.
 * @returns True if the version string is valid, false otherwise.
 *
 * @docsCategory preference/utils/semver
 * @docsPage semver-validate
 * @codeFilter validate
 */
export declare const validate: (ver: string) => boolean;
/**
 * @description
 * Sets the value at path of object. If a portion of path doesn't exist, it's created.
 *
 * @param source The object to modify.
 * @param path The path of the property to set.
 * @param value The value to set.
 *
 * @docsCategory preference/utils/set
 * @codeFilter set
 * @docsPage set
 */
export declare const set: (source: object | null | undefined, path: string, value: any) => object;
/**
 * @description
 * Convert string to camel case format
 *
 * @example
 * ``` ts
 * strCamelCase('--foo-bar--');
 * // => fooBar
 * strCamelCase('__FOO_ BAR__');
 * // => fooBar
 * strCamelCase('__FOO_- BAR__');
 * // => fooBar
 * ```
 *
 * @param str The string to be converted
 *
 * @docsCategory preference/utils/string
 * @codeFilter str-camel-case
 */
export declare const strCamelCase: (str: string) => string;
/**
 * @description
 * Converts strings of first character to uppercase
 *
 * @example
 * ``` ts
 * strCapitalize('FRED');
 * // => Fred
 * strCapitalize('');
 * // => ''
 * ```
 *
 * @param str The string to be converted
 *
 * @docsCategory preference/utils/string
 * @codeFilter str-capitalize
 */
export declare const strCapitalize: (str: string) => string;
/**
 * @description
 * Converts strings of first character to uppercase
 *
 * @example
 * ``` ts
 * strCapitalizeAll('Standard tax united states');
 * // => Standard Tax United States
 * strCapitalizeAll('Standard  tax    united  states');
 * // => Standard Tax United States
 * ```
 *
 * @param str The string to be converted
 *
 * @docsCategory preference/utils/string
 * @codeFilter str-capitalize-all
 */
export declare const strCapitalizeAll: (str: string) => string;
/**
 * @description
 * Clears string Spaces, or customizes cleared regular expressions
 * the default action to `Removes the space in the middle of the entire string`
 *
 * @example
 * ``` ts
 * strClean('F R ED');
 * // => FRED
 * strClean(' F R ED ');
 * // => FRED
 * ```
 *
 * @param str The input string.
 * @param pattern The pattern to be removed. Defaults to '\\s*' (any whitespace).
 * @returns The cleaned string.
 *
 * @docsCategory preference/utils/string
 * @codeFilter str-clean
 */
export declare const strClean: (str: string, pattern?: string) => string;
/**
 * @description
 * Formats a string.
 *
 * @param str The string to format.
 * @param pattern The formatting pattern. Default is '### #### ####'.
 * @returns The formatted string.
 *
 * @docsCategory preference/utils/string
 * @codeFilter str-format
 */
export declare const strFormat: (str: string, pattern?: string) => string;
/**
 * @description
 * Bank card number 16-19 digits, format to `#### #### #### #### ####`
 *
 * @example
 * ``` ts
 * strFormatBankcard('62226002600010724');
 * // => 6222 6002 6000 1072 4
 * strFormatBankcard('6222600260001072');
 * // => 6222 6002 6000 1072
 * strFormatBankcard('6222600260001072444');
 * // => 6222 6002 6000 1072 444
 * ```
 *
 * @param str String to be formatted
 *
 * @docsCategory preference/utils/string
 * @codeFilter str-format-bankcard
 */
export declare const strFormatBankcard: (str: string) => string;
/**
 * @description
 * The ID number is between 16 and 18 digits, format to `###### ######## ####`
 *
 * @example
 * ``` ts
 * strFormatIdcard('500102198692876443');
 * // => 500102 19869287 6443
 * strFormatIdcard('50010219869287643');
 * // => 500102 19869287 643
 * ```
 *
 * @param str String to be formatted
 *
 * @docsCategory preference/utils/string
 * @codeFilter str-format-idcard
 */
export declare const strFormatIdcard: (str: string) => string;
/**
 * @description
 * Phone number formatting with `### #### ####`
 *
 * @example
 * ``` ts
 * strFormatTel('13764826699');
 * // => 137 6482 6699
 * strFormatTel('13764826699883');
 * // => 137 6482 6699
 * strFormatTel('13764826');
 * // => 137 6482 6
 * ```
 *
 * @param str String to be formatted
 *
 * @docsCategory preference/utils/string
 * @codeFilter str-format-tel
 */
export declare const strFormatTel: (str: string) => string;
/**
 * @description
 * Convert string to camel case format
 *
 * @example
 * ``` ts
 * strKebabCase('Foo Bar', true);
 * // => foo-bar
 * strKebabCase('Foo bar', true);
 * // => foo-bar
 * strKebabCase('Foo bar', false);
 * // => Foo-bar
 * ```
 *
 * @param str The string to be converted
 * @param lowerCase If need to convert to lower case
 *
 * @docsCategory preference/utils/string
 * @codeFilter str-kebab-case
 */
export declare const strKebabCase: (str: string, lowerCase?: boolean) => string;
/**
 * @description
 * Generate a string with mask symbols
 *
 * @example
 * ``` ts
 * strMask('13764826699');
 * // => 137****6699
 * strMask('13764826699', '###----####');
 * // => 137----6699
 * strMask('tyc15129@qq.com', '###----###');
 * // => tyc----com
 * ```
 *
 * @param str string to be formatted
 * @param pattern default is `###****####`
 *
 * @docsCategory preference/utils/string
 * @codeFilter str-mask
 * @docsPage str-mask
 * @docsWeight 1
 */
export declare const strMask: (str?: string, pattern?: string) => string;
/**
 * @description
 * Fill the string left or right
 *
 * @example
 * ``` ts
 * strPad('12', 10, '0');
 * // => 1200000000
 * strPad('12', -5, '0');
 * // => 00012
 * strPad('12', -5, '*');
 * // => ***12
 * ```
 *
 * @param str String to be processed
 * @param length Total length of string will be filled to e.g. `-5` | `5` symbol `-` indicates directory `left`
 * @param value The default string to populate
 *
 * @docsCategory preference/utils/string
 * @codeFilter str-pad
 */
export declare const strPad: (str: string, length?: number, value?: string) => string;
/**
 * @description
 * Repeats a string a specified number of times.
 * - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat
 *
 * @example
 * ``` ts
 * strRepeat('0', 3);
 * // => '000'
 * strRepeat(' 12 3', 1);
 * // => ' 12 3'
 * strRepeat('123', 2);
 * // => '123123'
 * ```
 *
 * @param str - The string to repeat.
 * @param count - The number of times to repeat the string.
 * @returns The repeated string.
 * @throws {RangeError} If the count is negative, equal to Infinity, or would result in a string that exceeds the maximum size.
 *
 * @docsCategory preference/utils/string
 * @codeFilter str-repeat
 */
export declare const strRepeat: (str?: string, count?: number) => string;
/**
 * @description
 * Transforms a string from camel case to a specified symbol-separated case.
 *
 * @param str - The input string in camel case.
 * @param symbol - The symbol used to separate the words in the output string. It can be either '-' or '_'.
 * @returns The transformed string in the specified symbol-separated case.
 *
 * @docsCategory preference/utils/string
 * @codeFilter str-trans-camel
 */
export declare function strTransCamel(str: string, symbol: "-" | "_"): string;
/**
 * @description
 * Clears the Spaces before and after the string
 *
 * @example
 * ``` ts
 * strTrim('  foo  ');
 * // => foo
 * strTrim('\tfoo\t');
 * // => foo
 * strTrim(' F R ED ');
 * // => F R ED
 * ```
 *
 * @param str The string to be converted
 *
 * @docsCategory preference/utils/string
 * @codeFilter str-trim
 */
export declare const strTrim: (str: string) => string;
/**
 * @docsCategory preference/utils/tree
 */
export type Nullable<T> = {
	[P in keyof T]: T[P] | null | undefined;
};
/**
 * @docsCategory preference/utils/tree
 */
export type SetOptional<T, K extends keyof T> = Omit<T, K> & {
	[P in K]?: Nullable<T[P]>;
};
/**
 * 代表一个树节点的ID标识
 * @docsCategory preference/utils/tree
 */
export type TreeNodeId = string | number;
/**
 * @docsCategory preference/utils/tree
 */
export type TreeNodeItem = Record<string, unknown>;
export type ArrayPropertyKey<T> = keyof {
	[K in keyof T as T[K] extends readonly any[] ? K : "children"]: unknown;
};
/**
 * @docsCategory preference/utils/tree
 */
export type TreeNode<Node extends TreeNodeItem, Key extends ArrayPropertyKey<Node>> = Node & {
	[key in Key]: TreeNode<Node, Key>[];
};
/**
 * 一个是否展开属性状态(`expanded`)的转换之后的结构树
 * @docsCategory preference/utils/tree
 */
export type ExpandableTreeNode<Node extends TreeNodeItem, Key extends ArrayPropertyKey<Node>> = TreeNode<Node, Key> & {
	expanded?: boolean;
};
/**
 * 通常在生成树之前, 需要组织的treeNodes数据源, 通常是一个扁平数组
 * @docsCategory preference/utils/tree
 */
export type TreeNodeInput<Node extends TreeNodeItem, Key extends ArrayPropertyKey<Node>> = SetOptional<Node & {
	parent?: null | {
		id: TreeNodeId;
	};
	parentId?: null | TreeNodeId;
} & {
	[key in Key]: SetOptional<TreeNode<Node, Key>, "children">[];
}, "children">;
/**
 * 带带展开属性状态`expandable`新树
 * @docsCategory preference/utils/tree
 */
export type ExpandableTreeNodeResult<Node extends TreeNodeItem, Key extends ArrayPropertyKey<Node>> = TreeNodeInput<Node, Key> & {
	[key in Key]: ExpandableTreeNodeResult<Node, Key>[];
} & {
	expanded?: boolean;
};
/**
 *  代表一颗树转换之后, 生成新树带有`expandable`状态的时候根级的id应该是不存在的.
 * @docsCategory preference/utils/tree
 */
export type RootExpandableTreeNodeResult<Node extends TreeNodeItem, Key extends ArrayPropertyKey<Node>> = Node & {
	[key in Key]: ExpandableTreeNodeResult<Node, Key>[];
};
/**
 * @description
 * Converts an existing tree (as generated by the arrayToTree function) into a flat
 * Map. This is used to persist certain states (e.g. `expanded`) when re-building the
 * tree.
 *
 * @param nodes The flat nodes with optional property `parent`
 * @param currentState
 * @param childrenKey The children property of tree.
 * @returns
 *
 * @docsCategory preference/utils/tree
 * @codeFilter tree-array-to
 * @docsPage array-to-tree
 * @docsWeight 1
 */
export declare function arrayToTree<Node extends {
	id: TreeNodeId;
}, Key extends ArrayPropertyKey<Node>>(nodes: TreeNodeInput<Node, Key>[], currentState?: ExpandableTreeNode<Node, Key>, childrenKey?: Key): RootExpandableTreeNodeResult<Node, Key>;
/**
 * @description
 * Converts an existing tree (as generated by the arrayToTree function) into a flat
 * Map. This is used to persist certain states (e.g. `expanded`) when re-building the
 * tree.
 *
 * @param nodes The flat nodes with optional property `parent`
 * @param childrenKey The children property of tree.
 * @param parentIdFn The function to get the parentId of the node. default is `item.parent?.id??'null'`
 * @returns
 *
 * @docsCategory preference/utils/tree
 * @codeFilter tree-array-to2
 * @docsPage array-to-tree2
 * @docsWeight 1
 */
export declare const arrayToTree2: <Node extends {
	id: TreeNodeId;
}, Key extends ArrayPropertyKey<Node>>(nodes: TreeNodeInput<Node, Key>[], childrenKey?: Key, parentIdFn?: (item: TreeNodeInput<Node, Key>) => TreeNodeId | "null") => RootExpandableTreeNodeResult<Node, Key>;
/**
 * @description
 * Create a new tree consisting of copies of all nodes that pass test.
 * The tree is walked in preorder (NLR), visiting the node itself, then its head, etc.
 *
 * @param tree tree Tree to filter
 * @param test the test function predicate
 * @param options Whether to drop parent nodes if they had children, but all their children were filtered out.
 * @returns Promise\<TreeNode\<T\> | null\>
 *
 * @docsCategory preference/utils/tree
 * @codeFilter tree-filter
 * @docsPage filter-tree
 */
export declare function filterTree<Node extends TreeNodeItem, Key extends ArrayPropertyKey<Node>>(tree: TreeNode<Node, Key>, test: (node: TreeNode<Node, Key>, index?: number, parent?: TreeNode<Node, Key>, level?: number) => Promise<boolean>, options?: {
	cascade: boolean;
	childrenKey?: Key;
}): Promise<TreeNode<Node, Key> | null>;
/**
 * Create a new tree consisting of copies of all nodes that pass test.
 * The tree is walked in preorder (NLR), visiting the node itself, then its head, etc.
 * @param tree tree Tree to filter
 * @param test the test function predicate
 * @param options Whether to drop parent nodes if they had children, but all their children were filtered out.
 * @returns TreeNode<T> | null
 */
export declare function filterTreeSync<Node extends TreeNodeItem, Key extends ArrayPropertyKey<Node>>(tree: TreeNode<Node, Key>, test: (node: TreeNode<Node, Key>, index?: number, parent?: TreeNode<Node, Key>, level?: number) => boolean, options?: {
	cascade: boolean;
	childrenKey?: Key;
}): TreeNode<Node, Key> | null;
/**
 * @description
 * Represents a tree node with its ancestors and relations.
 *
 * @template Node - The type of the tree node.
 * @template Key - The type of the array property key of the tree node.
 *
 * @docsCategory preference/utils/tree
 * @docsPage find-ancestors-utils
 */
export type FindAncestorsTreeNodeWithRelation<Node extends TreeNodeItem, Key extends ArrayPropertyKey<Node>> = TreeNode<Node, Key> & {
	parentId?: number;
	id: TreeNodeId;
};
/**
 * @description
 * Recursively find tree node and all its ancestors (parents)
 * from a nested data structure (i.e. tree)
 *
 * @param nodes An array of data
 * @param predicate Filter criteria
 * @param childrenKey The key of tree children item
 * @return Matched node and its ancestors
 *
 * @docsCategory preference/utils/tree
 * @codeFilter tree-find-ancestors
 * @docsPage find-ancestors
 */
export declare function findAncestors<Node extends TreeNodeItem, Key extends ArrayPropertyKey<Node>>(nodes: TreeNode<Node, Key>[], predicate: (node: Node) => boolean, childrenKey?: Key): FindAncestorsTreeNodeWithRelation<Node, Key>[];
/**
 * @description
 * Converts a tree structure to an array of nodes.
 *
 * @param treeNodes - The array of tree nodes.
 * @param childrenKey - The property key used to access children nodes. If not provided, it defaults to "children".
 *
 * @returns An array of nodes representing the flattened tree structure.
 *
 * @docsCategory preference/utils/tree
 * @codeFilter tree-to-array
 */
export declare function treeToArray<Node extends TreeNodeItem, Key extends ArrayPropertyKey<Node>>(treeNodes: TreeNode<Node, Key>[], childrenKey?: Key): Node[];
/**
 * @description
 * Create a new tree consisting of copies of all nodes
 * The tree is walked in preorder (NLR), visiting the node itself, then its head, etc.
 *
 * @param tree tree Tree to update
 * @param onUpdate The hook method allow us to `update` every tree item
 * @param childrenKey The key of tree children item
 * @returns Promise\<TreeNode\<T,K\> | null\>
 *
 * @docsCategory preference/utils/tree
 * @codeFilter tree-update
 */
export declare function updateTree<Node extends TreeNodeItem, Key extends ArrayPropertyKey<Node>>(tree: TreeNode<Node, Key>, onUpdate: (node: TreeNode<Node, Key>, index?: number, parent?: TreeNode<Node, Key>) => Promise<TreeNode<Node, Key>>, childrenKey?: Key): Promise<TreeNode<Node, Key>>;
/**
 * Create a new tree consisting of copies of all nodes
 * The tree is walked in preorder (NLR), visiting the node itself, then its head, etc.
 * @param tree tree Tree to update
 * @param onUpdate The hook method allow us to `update` every tree item
 * @param childrenKey The key of tree children item
 * @returns Promise\<TreeNode\<T,K\> | null\>
 *
 * @docsCategory preference/utils/tree
 * @codeFilter tree-update-sync
 */
export declare function updateTreeSync<Node extends TreeNodeItem, Key extends ArrayPropertyKey<Node>>(tree: TreeNode<Node, Key>, onUpdate: (node: TreeNode<Node, Key>, index?: number, parent?: TreeNode<Node, Key>) => TreeNode<Node, Key>, childrenKey?: Key): TreeNode<Node, Key>;
/**
 * @docsCategory preference/utils/tree
 * @docsPage walk-through-tree
 * @docsWeight 3
 */
export type OnNodeWalked<Node extends TreeNodeItem, Key extends ArrayPropertyKey<Node>> = (node: TreeNode<Node, Key>, index?: number, parent?: TreeNode<Node, Key>, level?: number) => void;
/**
 * @description
 * Create a new tree consisting of copies of all nodes
 * The tree is walked in preorder (NLR), visiting the node itself, then its head, etc.
 *
 * @param tree The tree to walktrough
 * @param onNodeWalked The hook method to allow we walkThrough the tree node item.
 * @param childrenKey The key of tree children item
 *
 * @docsCategory preference/utils/tree
 * @codeFilter tree-walk-through
 * @docsPage walk-through-tree
 * @docsWeight 1
 */
export declare function walkThroughTree<Node extends TreeNodeItem, Key extends ArrayPropertyKey<Node>>(tree: TreeNode<Node, Key>, onNodeWalked: OnNodeWalked<Node, Key>, childrenKey?: Key): void;
/**
 * @description
 * Creates a new URL by combining the specified URLs
 *
 * @example
 * ``` ts
 * combineUrls('https://api.github.com/', '/users');
 * // => 'https://api.github.com/users'
 * combineUrls('https://api.github.com/users', '');
 * // => 'https://api.github.com/users'
 * ```
 *
 * @param {string|function} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 *
 * @docsCategory preference/utils/uri
 * @codeFilter combine-urls
 */
export declare const combineUrls: (baseURL: string | (() => string), relativeURL: string) => string;
/**
 * @description
 * Retrieves the value of a query parameter from a URL.
 *
 * @example
 * ``` ts
 * getQueryString('ntv_bar_hidden','http://localhost:20001/?ntv_bar_hidden=1#/_tc_ntv_bar_set_navbar_demo');
 * // => 1
 * getQueryString('xxx','http://localhost:20001/?ntv_bar_hidden=1#/_tc_ntv_bar_set_navbar_demo');
 * // => undefined
 * ```
 *
 * @param name - The name of the query parameter.
 * @param url - The URL to extract the query parameter from. If not provided, the current window location will be used.
 * @returns The value of the query parameter, or `undefined` if it doesn't exist.
 *
 * @docsCategory preference/utils/uri
 * @codeFilter get-query-string
 */
export declare function getQueryString(name: string, url?: string): string | undefined;
/**
 * @description
 * Retrieves the search parameter string from a given URL.
 *
 * @example
 * ``` ts
 * getSearchParamStr('http://localhost:20001/?ntv_bar_hidden&password=1#/_tc_ntv_bar_set_navbar_demo');
 * // => 'ntv_bar_hidden&password=1'
 * ```
 *
 * @param url - The URL from which to extract the search parameter string.
 * @returns The search parameter string without the hash symbol.
 *
 * @docsCategory preference/utils/uri
 * @codeFilter get-search-param-str
 */
export declare const getSearchParamStr: (url: string) => string;
/**
 * @description
 * Checks if a given query parameter exists in the URL.
 *
 * @example
 * ``` ts
 * hasQueryString('ntv_bar_hidden','http://localhost:20001/?ntv_bar_hidden#/_tc_ntv_bar_set_navbar_demo');
 * // => true
 * ```
 *
 * @param name - The name of the query parameter to check.
 * @param url - The URL to check. If not provided, the current window location will be used.
 * @returns A boolean indicating whether the query parameter exists in the URL.
 *
 * @docsCategory preference/utils/uri
 * @codeFilter has-query-string
 */
export declare const hasQueryString: (name: string, url?: string) => boolean;
/**
 * @description
 * Determines whether the specified URL is absolute
 *
 * @example
 * ``` ts
 * isAbsoluteUrl('123://example.com/');
 * // => false
 * isAbsoluteUrl('//example.com/');
 * // => true
 * isAbsoluteUrl('https://api.github.com/users');
 * // => true
 * ```
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 *
 * @docsCategory preference/utils/uri
 * @codeFilter is-absolute-url
 */
export declare const isAbsoluteUrl: (url: string) => boolean;
/**
 * @description
 * check if given url is http url or path
 *
 * @example
 * ``` ts
 * isHttpUrl('http://example.com');
 * // => true
 * isHttpUrl('ftp://example.com');
 * // => true
 * isHttpUrl('example.com');
 * // => false
 * ```
 *
 *
 * @param url url
 *
 * @docsCategory preference/utils/uri
 * @codeFilter is-http-url
 */
export declare const isHttpUrl: (url: string) => boolean | "";
/**
 * @description
 * Determine if a URL shares the same origin as the current location
 *
 * @example
 * ``` ts
 * isSameOrigin('https://github.com/axios/axios', 'https://github.com/test');
 * // => true
 * isSameOrigin('https://github.com/axios/axios');
 * // => false
 * ```
 *
 * @param {String} requestURL The URL to test
 * @returns {boolean} True if URL shares the same origin, otherwise false
 *
 * @docsCategory preference/utils/uri
 * @codeFilter is-same-origin
 */
export declare const isSameOrigin: (requestURL: string, url?: string) => boolean;
/**
 * @description
 * Modifies the query string of a given URL by adding or updating the specified parameters.
 *
 *
 * @example
 * ``` ts
 * modifyQueryString('https://example.org/abc', { user: 0 });
 * // => 'https://example.org/abc?user=0'
 * modifyQueryString('https://example.org/abc?abc=123', { abc: '1234' };
 * // => 'https://example.org/abc?abc=1234'
 * ```
 *
 * @param url - The URL to modify.
 * @param params - The parameters to add or update in the query string.
 * @returns The modified URL with the updated query string.
 *
 * @docsCategory preference/utils/uri
 * @codeFilter modify-query-string
 */
export declare const modifyQueryString: (url: string, params: object) => string;
/**
 * @description
 * Converts a URL parameter string to a JSON object.
 *
 *
 * @example
 * ``` ts
 * paramStrToJson('https://www.domaiin.com/catalog/kzfoo-glasses?facetValueIds=5-15-41-31-2-1&page=1&price=ASC');
 * // => {
 * // =>  facetValueIds: '5-15-41-31-2-1',
 * // =>  page: '1',
 * // =>  price: 'ASC',
 * // => }
 * ```
 *
 * @param url - The URL containing the parameter string.
 * @returns The JSON object representing the parameter string.
 *
 * @docsCategory preference/utils/uri
 * @codeFilter param-str-to-json
 */
export declare const paramStrToJson: (url: string) => {};
/**
 * @description
 * Normally for MD5(GET) signature, we need to remove `undefined`, `null`.
 * And convert all property value into `String` type. And sort `Array` property with alpha
 *
 * @example
 * ```ts
 * {
 *   foo: 'bar',
 *    // undefined will be removed.
 *    bar: undefined,
 *    // null will be removed.
 *    door: null,
 *    fex: '',
 *    fex2: ' ',
 *    child: {
 *      name: undefined,
 *      pwd: null,
 *      sex: 1,
 *      others: [3, 1, true, undefined],
 *    },
 *    array: ['name', '3', '1', true, null, undefined],
 *  }
 * // =>
 * {
 *    foo: 'bar',
 *    fex: '',
 *    fex2: ' ',
 *    child: {
 *      sex: '1',
 *      others: ['3', '1', 'true', 'undefined'],
 *    },
 *    array: ['name', '3', '1', true, null, undefined],
 * }
 * ```
 *
 * @param reqQuery - The request query object.
 * @returns The cleaned request query object.
 *
 * @docsCategory preference/utils/uri
 * @codeFilter params-clean.spec.ts
 */
export declare const paramsClean: (reqQuery: Record<string, unknown>) => unknown;
declare function encode(val: string): string;
/**
 * @description
 * Follow java url encode standard, serialize url query params to url string with encode
 * Normally it will used to parse params into api url querystring.
 *
 * @example
 * ```ts
 * {
 *     foo: 'bar',
 *     // undefined will be removed.
 *     bar: undefined,
 *     // null will be removed.
 *     door: null,
 *     fex: '',
 *     fex2: ' ',
 *     array: ['name', '3', '1', true, null, undefined],
 *  }
 * /foo?foo=bar&fex=&fex2=+&array=name&array=3&array=1&array=true&array=null&array=undefined
 * ```
 * @param params request parameters
 * @param encoder @default encode
 *
 * @docsCategory preference/utils/uri
 * @codeFilter params-serialize
 */
export declare const paramsSerialize: (params: Record<string, unknown>, encoder?: typeof encode) => string;
/**
 * @description
 * Removes a query string parameter from a URL.
 *
 * @param url - The URL from which to remove the query string parameter.
 * @param key - The key of the query string parameter to remove.
 * @returns The modified URL with the specified query string parameter removed.
 *
 * @docsCategory preference/utils/uri
 * @codeFilter remove-query-string
 */
export declare const removeQueryString: (url: string, key: string) => string;
/**
 * @description
 * Converts an object of parameters into a query string.
 *
 * @param params - The object containing the parameters.
 * @returns The query string representation of the parameters.
 *
 * @docsCategory preference/utils/uri
 * @codeFilter to-query-string
 */
export declare const toQueryString: (params: object) => string;
/**
 * @description
 * Parse a URL to discover it's components, Note the url must be with prefix `https://` or `http://`
 * Please don't use `//` prefix of uri.
 *
 *
 * @param {String} url The URL to be parsed
 * @returns {Object}
 *
 * @docsCategory preference/utils/uri
 * @codeFilter uri-parse
 */
export declare function uriParse(url: string): {
	href: string;
	protocol: string;
	host: string;
	hostname: string;
	port: string;
	pathname: string;
	search: string;
	hash: string;
} | {
	href?: undefined;
	protocol?: undefined;
	host?: undefined;
	hostname?: undefined;
	port?: undefined;
	pathname?: undefined;
	search?: undefined;
	hash?: undefined;
};
/**
 * @description
 * A function that returns a universally unique identifier (uuid).
 * Note: If used in long period data storage it is best to add a time stamp (e.g. logging)
 *
 * @example
 * ``` ts
 * uuid();
 * // => 1b83fd69-abe7-468c-bea1-306a8aa1c81d
 * ```
 *
 * @returns `string` : 32 character uuid (see example)
 *
 * @docsCategory preference/utils/uuid
 * @codeFilter uuid
 */
export declare const uuid: () => string;

export {};
